{
  "name": "Backend Chat API (Astro Integration)",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chat-api",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "607079fc-ce08-41f1-a097-b8cdcf9df830",
      "name": "Webhook (Entrée Unique)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -864,
        0
      ],
      "webhookId": "d41783e1-c8f6-4aba-bd51-5016acb5582a"
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.action }}",
        "rules": {
          "rules": [
            {
              "value2": "auth-init"
            },
            {
              "value2": "auth-verify",
              "output": 1
            },
            {
              "value2": "chat-message",
              "output": 3
            },
            {
              "value2": "refresh-token",
              "output": 2
            }
          ]
        }
      },
      "id": "a1b92604-3dc8-44b0-a426-d12f95124f7d",
      "name": "Router (Switch Action)",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [
        -336,
        -48
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\n// 1. Générer un code à 4 chiffres (pour l'utilisateur)\nconst code = Math.floor(1000 + Math.random() * 9000).toString();\n\n// 2. Créer le hash du code (pour la base de données)\n// On utilise SHA-256 qui est robuste\nconst codeHash = crypto.createHash('sha256').update(code).digest('hex');\n\n// Récupération sécurisée de l'email\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst email = body ? body.email : 'no-email-found';\n\nreturn {\n  email: email,\n  generated_code: code,      // NON-HASHÉ : À envoyer par email\n  code_hash: codeHash,       // HASHÉ : À stocker en DB\n  created_at: new Date().toISOString()\n};"
      },
      "id": "becce18e-f3f7-48f1-9d7e-ddaad8a0df4b",
      "name": "Générer Code OTP",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1408,
        -416
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const crypto = require('crypto');\n\n// 1. Récupération des inputs\nconst webhook = $('Webhook (Entrée Unique)').first().json;\nconst email = webhook.body.email;\nconst receivedCode = String(webhook.body.code).trim(); // Le '1234' tapé par l'utilisateur\n\n// 2. Données stockées (HASHÉES)\nconst storedHash = $json.code; // Attention: la colonne s'appelle toujours 'code' mais contient le hash\nconst storedDate = $json.created_at;\nconst rowId = $json.id;\n\nif (!storedHash) {\n  throw new Error(\"Aucun OTP trouvé pour cet email.\");\n}\n\n// 3. Vérification de l'expiration (5 min)\nconst EXPIRATION_MS = 5 * 60 * 1000;\nconst now = new Date().getTime();\nconst createdAt = new Date(storedDate).getTime();\n\nif (now - createdAt > EXPIRATION_MS) {\n  throw new Error(\"Code OTP expiré. Veuillez en demander un nouveau.\");\n}\n\n// 4. HASHAGE ET COMPARAISON\n// On hashe le code reçu pour voir s'il correspond au hash stocké\nconst receivedCodeHash = crypto.createHash('sha256').update(receivedCode).digest('hex');\n\nif (receivedCodeHash !== storedHash) {\n  throw new Error(\"Code OTP invalide.\");\n}\n\n// 5. Succès\nreturn {\n  email,\n  valid: true,\n  rowIdToDelete: rowId\n};"
      },
      "id": "118ee0a6-ae67-4b17-a6dc-1c8e04bb5949",
      "name": "Vérifier Code (Mock)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1072,
        -208
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "operation": "verify",
        "token": "={{ $('Webhook (Entrée Unique)').item.json.headers.authorization.split(' ')[1] }}",
        "options": {}
      },
      "id": "df6d0768-127c-4c31-939d-cac7b7857f20",
      "name": "Sécurité (Vérifier JWT)",
      "type": "n8n-nodes-base.jwt",
      "typeVersion": 1,
      "position": [
        -16,
        624
      ],
      "credentials": {
        "jwtAuth": {
          "id": "MSrsIWMcCZiwYCvf",
          "name": "JWT Auth account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "resource": "audio",
        "operation": "transcribe",
        "binaryPropertyName": "audio",
        "options": {}
      },
      "id": "67017386-f107-481a-b8a2-e95042dcaf6c",
      "name": "Whisper (STT)",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [
        688,
        432
      ],
      "credentials": {
        "openAiApi": {
          "id": "pe1RxUmCYaJzcwAP",
          "name": "OpenAi account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "d9422e89-aac0-4b77-a874-ca61904828e8",
      "name": "Réponse Init",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1984,
        -416
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ \n  (() => {\n    // On cherche d'abord si la branche Login a produit quelque chose\n    let data = null;\n    try {\n        const loginItem = $('Générer Refresh Token').last(); \n        if (loginItem && loginItem.json && loginItem.json.accessToken) {\n            data = loginItem.json;\n        }\n    } catch (e) {}\n\n    // Si rien, on cherche dans la branche Refresh\n    if (!data) {\n        try {\n            const refreshItem = $('Générer Refresh Token 1').last();\n            if (refreshItem && refreshItem.json && refreshItem.json.accessToken) {\n                data = refreshItem.json;\n            }\n        } catch (e) {}\n    }\n\n    // Retourne le JSON stringifié (impératif pour ce champ)\n    if (data) {\n        return JSON.stringify({\n            accessToken: data.accessToken,\n            refreshToken: data.refreshToken\n        });\n    }\n    return JSON.stringify({ error: \"Tokens introuvables\" });\n  })()\n}}",
        "options": {}
      },
      "id": "b79b1af1-2670-4617-9815-7f4510c6b635",
      "name": "Réponse Token",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        2192,
        0
      ]
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "509c9366-8442-4a2f-b28a-a8cb4b75256d",
      "name": "Réponse Chat",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1888,
        624
      ]
    },
    {
      "parameters": {
        "fromEmail": "contact@gehringer.fr",
        "toEmail": "={{ $json.email }}",
        "subject": "Your code",
        "html": "=Bonjour,\n\nvoici le code pour chatter: {{ $('Générer Code OTP').item.json.generated_code }}\n\nEn continuant, vous acceptez que votre email soit utilisé pour traiter votre demande.\n\nMerci !",
        "options": {
          "appendAttribution": false,
          "bccEmail": "philippe.lakas@gmail.com",
          "replyTo": "web.contact@gehringer.fr"
        }
      },
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        2176,
        -416
      ],
      "id": "c2eaab83-ee18-4ddb-8dee-0089e80543b7",
      "name": "Send email",
      "webhookId": "25e76513-a504-43d5-9a46-87dc60e1b24a",
      "credentials": {
        "smtp": {
          "id": "IpKC6W2ftYil9cca",
          "name": "SMTP account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "IWWDAHh3QCefwYYN",
          "mode": "list",
          "cachedResultName": "OTP_Codes",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/IWWDAHh3QCefwYYN"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "code": "={{ $json.code_hash }}",
            "email": "={{ $json.email }}",
            "created_at": "={{ $json.created_at }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "code",
              "displayName": "code",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1584,
        -416
      ],
      "id": "a1ac1318-15d7-41ba-af39-b16cc506c52d",
      "name": "Sécu: Stocker Code"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "IWWDAHh3QCefwYYN",
          "mode": "list",
          "cachedResultName": "OTP_Codes",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/IWWDAHh3QCefwYYN"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        896,
        -208
      ],
      "id": "b89f0354-7cfb-4d5a-bc9d-3a83f0c4b7a1",
      "name": "Get stored OTP code"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "yfw8czdVcKrGjiy1",
          "mode": "list",
          "cachedResultName": "CRM_Contacts",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/yfw8czdVcKrGjiy1"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.body.email }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1056,
        -416
      ],
      "id": "a9af5ab6-92c5-47a4-8983-c295ceead384",
      "name": "Get CRM Contact",
      "alwaysOutputData": true,
      "notes": "Est-ce que l'email existe ?"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "yfw8czdVcKrGjiy1",
          "mode": "list",
          "cachedResultName": "CRM_Contacts",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/yfw8czdVcKrGjiy1"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $('Webhook (Entrée Unique)').item.json.body.email }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "interaction_count": "={{ (Number($('Get CRM Contact').first().json.interaction_count) || 0) + 1 }}",
            "last_seen": "={{ new Date().toISOString() }}",
            "email": "={{ $('Webhook (Entrée Unique)').item.json.body.email }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "interaction_count",
              "displayName": "interaction_count",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "last_seen",
              "displayName": "last_seen",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1232,
        -416
      ],
      "id": "e883c8b2-f6a7-498d-9db7-f7d5b741a8fd",
      "name": "Update CRM",
      "notes": "Màj de CRM"
    },
    {
      "parameters": {
        "jsCode": "// Récupération chirurgicale du binaire depuis le Webhook initial\nconst binaryData = $('Webhook (Entrée Unique)').first().binary;\n\nreturn [{\n  json: items[0].json, // On garde le JSON courant (token, etc.)\n  binary: binaryData   // On réinjecte le binaire manquant\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        512,
        432
      ],
      "id": "65407b8f-758b-49c5-9e83-a893b2820809",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.text || $('Webhook (Entrée Unique)').item.json.body.text }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        864,
        624
      ],
      "id": "f773954f-0e6d-404e-bc5d-ca076553522f",
      "name": "AI Agent",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-nano",
          "mode": "list",
          "cachedResultName": "gpt-4.1-nano"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        864,
        448
      ],
      "id": "56fc8bf3-71b2-4516-bb8d-a394448ba709",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "pe1RxUmCYaJzcwAP",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "url": "https://people.googleapis.com/v1/contactGroups",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleContactsOAuth2Api",
        "options": {}
      },
      "id": "67e211e2-527e-4c6d-946f-e4ca2c343202",
      "name": "Get All Groups",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1312,
        -16
      ],
      "credentials": {
        "googleContactsOAuth2Api": {
          "id": "xyMVAK068yLHLVtF",
          "name": "Google Contacts account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "https://people.googleapis.com/v1/people:searchContacts",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleContactsOAuth2Api",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "query",
              "value": "={{ $json.email }}"
            },
            {
              "name": "readMask",
              "value": "names,emailAddresses,memberships"
            }
          ]
        },
        "options": {}
      },
      "id": "2a609d1c-5f7a-4bfb-be25-5a370d9d86da",
      "name": "Check Google Contacts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        1136,
        -16
      ],
      "alwaysOutputData": true,
      "retryOnFail": true,
      "credentials": {
        "googleContactsOAuth2Api": {
          "id": "xyMVAK068yLHLVtF",
          "name": "Google Contacts account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const response = $('Check Google Contacts').first().json;\n// The API returns { results: [ { person: { ... } } ] }\n// If no results, 'results' is undefined or empty\nconst person = (response.results && response.results.length > 0) ? response.results[0].person : {};\n\nconst groups = $('Get All Groups').first().json.contactGroups || [];\n\n// Create Map: resourceName -> formattedName\nconst groupMap = {};\ngroups.forEach(g => {\n  groupMap[g.resourceName] = g.formattedName;\n});\n\n// Extract User Memberships (safe access)\nconst rawMemberships = person.memberships || [];\n\nconst labels = rawMemberships.map(m => {\n   const resName = m.contactGroupMembership ? m.contactGroupMembership.contactGroupResourceName : null;\n   return groupMap[resName] || resName;\n}).filter(l => l != null);\n\n// Fallback email if contact not found\n// Note: original email input is needed if person.emailAddresses is empty\nconst verifiedEmail = $('Vérifier Code (Mock)').first().json.email;\nconst googleEmail = (person.emailAddresses && person.emailAddresses.length > 0) ? person.emailAddresses[0].value : null;\n\nreturn {\n  email: googleEmail || verifiedEmail,\n  user_labels: labels\n};"
      },
      "id": "ab741e30-9b81-4134-b902-59b6e1dcd7c2",
      "name": "Merge Groups Names",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1488,
        -16
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "mode": "expression",
        "numberOutputs": 3,
        "output": "={{ ($('Webhook (Entrée Unique)').first().binary?.audio != null || ($('Webhook (Entrée Unique)').first().binary?.data?.mimeType?.startsWith('audio/') || false)) ? 0 : (($('Webhook (Entrée Unique)').first().binary?.file != null || $('Webhook (Entrée Unique)').first().binary?.data != null) ? 1 : 2) }}"
      },
      "id": "fa43b519-89c3-475f-8ed7-9a0124a96f93",
      "name": "Router (Content Type)",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        336,
        608
      ],
      "notesInFlow": false
    },
    {
      "parameters": {
        "jsCode": "const inputBinary = $('Webhook (Entrée Unique)').first().binary;\nconst binary = inputBinary ? (inputBinary.file || inputBinary.data) : null;\nconst fileName = binary ? binary.fileName : 'unknown_file';\nconst fileType = binary ? binary.mimeType : 'unknown_type';\n\n// Placeholder: In a full implementation, this node would extract text from PDF/Docx\n// or pass the file to an RAG ingestion workflow.\n\nreturn [\n  {\n    json: {\n      text: `[SYSTEM] L'utilisateur a envoyé un fichier : \"${fileName}\" (${fileType}). ${$json.text ? 'Message accompagné : ' + $json.text : ''}`,\n      has_attachment: true,\n      attachment_name: fileName,\n      attachment_type: fileType\n    }\n  }\n];"
      },
      "id": "3deae9cd-3fda-44da-bf47-ce079a78bb59",
      "name": "Process Document",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        512,
        624
      ]
    },
    {
      "parameters": {
        "operation": "deleteRows",
        "dataTableId": {
          "__rl": true,
          "value": "IWWDAHh3QCefwYYN",
          "mode": "list",
          "cachedResultName": "OTP_Codes",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/IWWDAHh3QCefwYYN"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyValue": "={{ $json.rowIdToDelete }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1232,
        -208
      ],
      "id": "50a16a21-dffe-4278-8599-bd2cca29ac97",
      "name": "Supprimé Code Utilisé"
    },
    {
      "parameters": {
        "useJson": true,
        "claimsJson": "={\n  \"expiresIn\": 900,\n  \"email\": \"{{ $('Vérifier Code (Mock)').first().json.email }}\",\n  \"user_labels\": \"{{ $json.user_labels || [] }}\"\n}",
        "options": {}
      },
      "id": "a66859a8-d736-472a-91cc-fcb1f4173fd4",
      "name": "Générer Access Token",
      "type": "n8n-nodes-base.jwt",
      "typeVersion": 1,
      "position": [
        1584,
        -208
      ],
      "notesInFlow": true,
      "credentials": {
        "jwtAuth": {
          "id": "MSrsIWMcCZiwYCvf",
          "name": "JWT Auth account"
        }
      },
      "notes": "Token sert aux requêtes immédiates du chat"
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\n// 1. Récupérer l'Access Token généré juste avant (il est dans la propriété \"token\" ou la clé principale selon votre version)\n// Note: Le noeud JWT met souvent le résultat dans une propriété. Vérifiez l'input.\nconst accessToken = $json.token || $json; \nconst email = $('Vérifier Code (Mock)').first().json.email;\n\n// 2. Générer le Refresh Token (Opaque String)\nconst refreshToken = crypto.randomBytes(40).toString('hex');\n\n// 3. Calculer le Hash pour la base de données (SHA-256)\nconst tokenHash = crypto.createHash('sha256').update(refreshToken).digest('hex');\n\n// 4. Calculer la date d'expiration (+7 jours)\nconst expiry = new Date();\nexpiry.setDate(expiry.getDate() + 7);\n\nreturn {\n  email: email,\n  accessToken: accessToken,      // Le JWT court\n  refreshToken: refreshToken,    // Le secret à envoyer à l'utilisateur\n  tokenHash: tokenHash,          // Le hash à stocker\n  expiresAt: expiry.toISOString()\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1776,
        -208
      ],
      "id": "c1bb37ab-b14a-48b5-b514-88360411e0bb",
      "name": "Générer Refresh Token"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "revoked": false,
            "email": "={{ $json.email }}",
            "token_hash": "={{ $json.tokenHash }}",
            "expires_at": "={{ $json.expiresAt }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "token_hash",
              "displayName": "token_hash",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "expires_at",
              "displayName": "expires_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "revoked",
              "displayName": "revoked",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {
          "optimizeBulk": false
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1984,
        -208
      ],
      "id": "607d7d55-0e63-4bc9-afe4-6b3b2f5147d5",
      "name": "Sauvegarder Refresh Token"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "ytaFSb3YU5YIFY0q",
          "mode": "list",
          "cachedResultName": "Audit_Logs",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/ytaFSb3YU5YIFY0q"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{ new Date().toISOString() }}",
            "email": "={{ $json.email }}",
            "action": "=auth-verify",
            "status": "=success",
            "ip_address": "={{ $('Webhook (Entrée Unique)').first().json.headers['cf-connecting-ip'] || $('Webhook (Entrée Unique)').first().json.headers['x-forwarded-for'] }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "details",
              "displayName": "details",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": true
            },
            {
              "id": "ip_address",
              "displayName": "ip_address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1408,
        -208
      ],
      "id": "96dcbe9e-c4d3-4bdd-92c4-e375d774635b",
      "name": "Log: Auth Success"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"error\": \"{{ $json.details.replace(/ \\[line \\d+\\]/, '') }}\"\n}",
        "options": {
          "responseCode": 400
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        2176,
        240
      ],
      "id": "4a3e003d-6e22-4fc8-9e0c-957b055f16c5",
      "name": "Erreur Auth"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "ytaFSb3YU5YIFY0q",
          "mode": "list",
          "cachedResultName": "Audit_Logs",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/ytaFSb3YU5YIFY0q"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{ new Date().toISOString() }}",
            "email": "={{ $('Webhook (Entrée Unique)').first().json.body.email }}",
            "action": "=auth-verify-fail",
            "status": "=error",
            "ip_address": "={{ $('Webhook (Entrée Unique)').first().json.headers['cf-connecting-ip'] }}",
            "details": "={{ $json.error }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "details",
              "displayName": "details",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "ip_address",
              "displayName": "ip_address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1984,
        240
      ],
      "id": "7810dd5b-e6c3-4f58-9389-690be3ee9335",
      "name": "Log: Auth Failed"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "ytaFSb3YU5YIFY0q",
          "mode": "list",
          "cachedResultName": "Audit_Logs",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/ytaFSb3YU5YIFY0q"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{ new Date().toISOString() }}",
            "email": "={{ $json.payload.email }}",
            "action": "=chat-message",
            "status": "=success",
            "ip_address": "={{ $('Webhook (Entrée Unique)').first().json.headers['cf-connecting-ip'] }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "details",
              "displayName": "details",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": true
            },
            {
              "id": "ip_address",
              "displayName": "ip_address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        144,
        624
      ],
      "id": "f6efdce2-86f6-4b77-8d48-c2ad880fe726",
      "name": "Log: Chat Message"
    },
    {
      "parameters": {
        "jsCode": "// Harmonise l'erreur quelle que soit sa source\nconst errorItem = $input.item.json;\nlet msg = errorItem.message || errorItem.error || \"Erreur inconnue\";\n\n// Nettoyage cosmétique\nmsg = msg.replace(/ \\[line \\d+\\]/, ''); \n\n// Détection du code HTTP suggéré\nlet status = 400;\nif (msg.includes('jwt expired') || msg.includes('token')) status = 401;\nif (msg.includes('connection') || msg.includes('timeout')) status = 503;\n\nreturn {\n  error: msg,  // Message propre pour l'utilisateur\n  raw_error: JSON.stringify(errorItem), // Pour les logs\n  http_status: status // Pour le nœud Response\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1792,
        240
      ],
      "id": "c1b20fcb-d262-4173-9988-53dd9295cdd5",
      "name": "Normaliseur d'Erreur"
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n// On s'assure d'avoir le token, qu'il vienne du body ou d'ailleurs\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst refreshToken = body.refreshToken;\n\nif (!refreshToken) {\n  throw new Error(\"Refresh Token manquant dans la requête.\");\n}\n\n// Hashage\nconst hash = crypto.createHash('sha256').update(refreshToken).digest('hex');\n\nreturn { \n  token_hash_to_find: hash,\n  original_token: refreshToken\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -48,
        224
      ],
      "id": "e6be36d9-617c-49f1-834f-9cf1bb785a8d",
      "name": "Hash Incoming Token"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "token_hash",
              "keyValue": "={{ $json.token_hash_to_find }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        112,
        224
      ],
      "id": "a5252e7d-57fe-4d08-98ad-af2fd260ce5f",
      "name": "Get Refresh Token Info",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const storedToken = $input.item.json;\n\n// 1. Vérifications\nif (!storedToken || !storedToken.id) { // Si pas d'ID, c'est que rien n'a été trouvé\n   throw new Error(\"Refresh token introuvable ou invalide.\");\n}\n\nif (storedToken.revoked) {\n   throw new Error(\"Ce token a été révoqué.\");\n}\n\nconst expiresAt = new Date(storedToken.expires_at).getTime();\nif (Date.now() > expiresAt) {\n   throw new Error(\"Refresh token expiré (Session terminée).\");\n}\n\n// 2. Préparer la suite (On renvoie l'email pour le futur JWT)\nreturn {\n   email: storedToken.email,\n   oldTokenId: storedToken.id // ID à supprimer pour la rotation\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        288,
        224
      ],
      "id": "e6905f2c-4dbd-4c71-84b2-edf9a241f23e",
      "name": "Validate & Rotate"
    },
    {
      "parameters": {
        "operation": "deleteRows",
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "filters": {
          "conditions": [
            {
              "keyValue": "={{ $json.oldTokenId }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        464,
        224
      ],
      "id": "b6b57e6c-6956-4f80-abc4-a0c397383d4b",
      "name": "Delete Old Token"
    },
    {
      "parameters": {
        "useJson": true,
        "claimsJson": "={\n  \"expiresIn\": 900,\n  \"email\": \"{{ $json.email }}\",\n  \"user_labels\": \"{{ $json.user_labels || [] }}\"\n}",
        "options": {}
      },
      "id": "1bb09809-7a56-4c01-a72a-860787d0f8f3",
      "name": "Générer Access Token 1",
      "type": "n8n-nodes-base.jwt",
      "typeVersion": 1,
      "position": [
        672,
        224
      ],
      "notesInFlow": true,
      "credentials": {
        "jwtAuth": {
          "id": "MSrsIWMcCZiwYCvf",
          "name": "JWT Auth account"
        }
      },
      "notes": "Token sert aux requêtes immédiates du chat"
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\n// 1. Récupérer l'Access Token généré juste avant (il est dans la propriété \"token\" ou la clé principale selon votre version)\n// Note: Le noeud JWT met souvent le résultat dans une propriété. Vérifiez l'input.\nconst accessToken = $json.token || $json; \nconst email = $('Vérifier Code (Mock)').first().json.email;\n\n// 2. Générer le Refresh Token (Opaque String)\nconst refreshToken = crypto.randomBytes(40).toString('hex');\n\n// 3. Calculer le Hash pour la base de données (SHA-256)\nconst tokenHash = crypto.createHash('sha256').update(refreshToken).digest('hex');\n\n// 4. Calculer la date d'expiration (+7 jours)\nconst expiry = new Date();\nexpiry.setDate(expiry.getDate() + 7);\n\nreturn {\n  email: email,\n  accessToken: accessToken,      // Le JWT court\n  refreshToken: refreshToken,    // Le secret à envoyer à l'utilisateur\n  tokenHash: tokenHash,          // Le hash à stocker\n  expiresAt: expiry.toISOString()\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        864,
        224
      ],
      "id": "b3cd6dad-0cfa-4f01-9c91-d09fb3975abe",
      "name": "Générer Refresh Token 1"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "revoked": false,
            "email": "={{ $json.email }}",
            "token_hash": "={{ $json.tokenHash }}",
            "expires_at": "={{ $json.expiresAt }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "token_hash",
              "displayName": "token_hash",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "expires_at",
              "displayName": "expires_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "revoked",
              "displayName": "revoked",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1072,
        224
      ],
      "id": "42ef9149-d68c-40e8-bce8-1714050dc666",
      "name": "Sauvegarder Refresh Token 1"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.body.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "=auth-init"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -96,
        -416
      ],
      "id": "f8af0b6d-d5e0-4b5e-9481-2c2d32f1f5de",
      "name": "Get Rate Limit Init",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const limit = $input.item.json; // Résultat de la DB\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst email = body.email;\nconst now = new Date();\n\n// Configuration\nconst MAX_ATTEMPTS = 3;\nconst WINDOW_MINUTES = 15;\nconst BLOCK_MINUTES = 30;\n\nlet newCount = 1;\nlet firstDates = now.toISOString();\nlet blockedUntil = null;\nlet errorMessage = null; // Variable pour stocker l'erreur potentielle\n\n// Vérifier si déjà un enregistrement\nif (limit.id) {\n  // 1. Est-il DÉJÀ bloqué ?\n  if (limit.blocked_until && new Date(limit.blocked_until) > now) {\n     const minutesLeft = Math.ceil((new Date(limit.blocked_until) - now) / 60000);\n     errorMessage = `Trop de tentatives. Réessayez dans ${minutesLeft} minutes.`;\n     // On garde les anciennes valeurs pour ne pas les écraser\n     newCount = limit.count;\n     firstDates = limit.first_attempt_at;\n     blockedUntil = limit.blocked_until;\n     \n  } else {\n      // 2. Vérification de la fenêtre de temps\n      const firstAttempt = new Date(limit.first_attempt_at);\n      const diffMinutes = (now - firstAttempt) / 60000;\n\n      if (diffMinutes > WINDOW_MINUTES) {\n         // Fenêtre expirée, on reset tout\n         newCount = 1;\n         firstDates = now.toISOString();\n         blockedUntil = null;\n      } else {\n         // Dans la fenêtre, on incrémente\n         newCount = (limit.count || 0) + 1;\n         firstDates = limit.first_attempt_at;\n         \n         if (newCount > MAX_ATTEMPTS) {\n            // On bloque MAINTENANT\n            const blockDate = new Date(now.getTime() + BLOCK_MINUTES * 60000);\n            blockedUntil = blockDate.toISOString();\n            errorMessage = \"Trop de demandes de code. Compte bloqué 30 min.\";\n         }\n      }\n  }\n}\n\nreturn {\n   email: email,\n   action: 'auth-init', // Rappel : Mettre 'auth-verify' pour l'autre branche\n   count: newCount,\n   first_attempt_at: firstDates,\n   blocked_until: blockedUntil,\n   error_to_throw: errorMessage // LA clé magique\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        -416
      ],
      "id": "8a23e2d0-a85f-48dc-a10d-8316e3374d0c",
      "name": "Check Limit Init"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "={{ $json.action }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "count": "={{ $json.count }}",
            "email": "={{ $json.email }}",
            "action": "={{ $json.action }}",
            "first_attempt_at": "={{ $json.first_attempt_at }}",
            "blocked_until": "={{ $json.blocked_until }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "count",
              "displayName": "count",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "first_attempt_at",
              "displayName": "first_attempt_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "blocked_until",
              "displayName": "blocked_until",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        256,
        -416
      ],
      "id": "aa62709e-ec39-4f5f-9092-0963dc72523d",
      "name": "Update Rate Limit Init"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.body.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "=auth-verify"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -96,
        -192
      ],
      "id": "3c5f7c69-b7de-4679-9944-7af628ed2ab1",
      "name": "Get Rate Limit Verify",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const limit = $input.item.json; // Résultat de la DB\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst email = body.email;\nconst now = new Date();\n\n// Configuration SPECIFIQUE 'Verify'\nconst MAX_ATTEMPTS = 5;      // 5 essais\nconst WINDOW_MINUTES = 5;    // En 5 minutes\nconst BLOCK_MINUTES = 30;    // Blocage 30 min\n\nlet newCount = 1;\nlet firstDates = now.toISOString();\nlet blockedUntil = null;\nlet errorMessage = null;\n\n// Vérifier si déjà un enregistrement\nif (limit.id) {\n  // 1. Est-il DÉJÀ bloqué ?\n  if (limit.blocked_until && new Date(limit.blocked_until) > now) {\n     const minutesLeft = Math.ceil((new Date(limit.blocked_until) - now) / 60000);\n     errorMessage = `Compte bloqué. Réessayez dans ${minutesLeft} minutes.`;\n     newCount = limit.count;\n     firstDates = limit.first_attempt_at;\n     blockedUntil = limit.blocked_until;\n     \n  } else {\n      // 2. Vérification de la fenêtre de temps\n      const firstAttempt = new Date(limit.first_attempt_at);\n      const diffMinutes = (now - firstAttempt) / 60000;\n\n      if (diffMinutes > WINDOW_MINUTES) {\n         // Fenêtre expirée, on reset\n         newCount = 1;\n         firstDates = now.toISOString();\n         blockedUntil = null;\n      } else {\n         // Dans la fenêtre, on incrémente\n         newCount = (limit.count || 0) + 1;\n         firstDates = limit.first_attempt_at;\n         \n         if (newCount > MAX_ATTEMPTS) {\n            // On bloque MAINTENANT\n            const blockDate = new Date(now.getTime() + BLOCK_MINUTES * 60000);\n            blockedUntil = blockDate.toISOString();\n            errorMessage = \"Trop d'essais incorrects. Compte bloqué 30 min.\";\n         }\n      }\n  }\n}\n\nreturn {\n   email: email,\n   action: 'auth-verify', // Important : c'est l'action 'verify' ici\n   count: newCount,\n   first_attempt_at: firstDates,\n   blocked_until: blockedUntil,\n   error_to_throw: errorMessage\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        80,
        -192
      ],
      "id": "8d9219ab-5135-404b-9d89-f36991880d49",
      "name": "Check Limit Verify"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "={{ $json.action }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "count": "={{ $json.count }}",
            "email": "={{ $json.email }}",
            "action": "={{ $json.action }}",
            "first_attempt_at": "={{ $json.first_attempt_at }}",
            "blocked_until": "={{ $json.blocked_until }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "count",
              "displayName": "count",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "first_attempt_at",
              "displayName": "first_attempt_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "blocked_until",
              "displayName": "blocked_until",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        256,
        -192
      ],
      "id": "450eed04-ac77-4198-b8b1-84b690117d31",
      "name": "Update Rate Limit Verify"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "02fd86a9-959e-4873-9517-4fa10b9b33e0",
              "leftValue": "={{ $('Check Limit Init').first().json.error_to_throw }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        464,
        -416
      ],
      "id": "695bc1ef-572d-4088-b703-c7c3f761913b",
      "name": "Block or Pass"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict",
            "version": 3
          },
          "conditions": [
            {
              "id": "10a2a8e3-7539-46f0-89fd-e1f9b1673715",
              "leftValue": "={{ $('Check Limit Verify').first().json.error_to_throw }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty",
                "singleValue": true
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        464,
        -192
      ],
      "id": "06d27868-e369-4d73-8145-63dc1d582105",
      "name": "Block or Pass Verify"
    },
    {
      "parameters": {
        "content": "## Gestion des erreurs (à peaufiner)\n(Si votre variable s'appelle $json.error ou $json.message, adaptez juste le début. Le .replace(...) est standard).\n\n2. Centraliser la gestion des erreurs (Branche \"Catch-All\")\nAbsolument ! C'est même une \"best practice\" en architecture n8n appelée le pattern Error Workflow ou Error Trigger.\n\nMais sans créer un workflow séparé complexe, vous pouvez tout à fait connecter plusieurs nœuds à votre branche d'erreur existante.\n\nComment ça marche ? Pour chaque nœud critique, vous allez dans ses Settings -> On Error -> Continue (using error output). Cela fait apparaître la 2ème sortie (grise/rouge). Vous tirez ensuite un fil de cette sortie vers l'entrée de votre branche \"Erreur\" (le nœud Log: Auth Failed ou directement Erreur Auth).\n\nListe des nœuds à connecter (suggérés) :\n\nSécurité (Vérifier JWT) : ESSENTIEL.\nSi le token est expiré ou invalide, cela plante le workflow. En le connectant à Erreur Auth, l'utilisateur recevra un propre 401/400 et le Frontend pourra (comme on l'a codé hier) lui dire \"Session expirée\".\nNote : Modifiez le message d'erreur dans Erreur Auth pour gérer le cas spécifique (ex: si le message contient \"jwt expired\", renvoyer un code HTTP 401).\nCheck Google Contacts (HTTP Request) :\nSi l'API Google est en panne ou rejette la requête (quota, erreur 500), le workflow s'arrête.\nConnectez-le pour dire \"Service temporairement indisponible\".\nWhisper (STT) & OpenAI Chat Model :\nSi OpenAI est down ou timeout, c'est critique de prévenir l'utilisateur (\"L'IA ne répond pas pour le moment\").\nSend Email :\nSi le SMTP échoue, l'utilisateur attend son code pour rien. Il vaut mieux lui dire \"Impossible d'envoyer l'email, réessayez\".\nAttention à la structure du JSON d'erreur ! Quand un nœud plante, il sort un JSON qui ressemble souvent à :\n\njson\n{\n  \"message\": \"Error description\",\n  \"name\": \"NodeApiError\",\n  ...\n}\nVotre nœud Log: Auth Failed attend actuellement un champ bien précis pour le details. L'astuce est d'insérer un petit nœud Code (ou \"Edit Fields\") juste au début de votre branche erreur commune qui normalise tout ça :\n\nArchitecture Recommandée :\n\nmermaid\ngraph TD\n    A[Vérifier Code] -- Error --> X[Normaliseur d'Erreur]\n    B[Vérifier JWT] -- Error --> X\n    C[OpenAI] -- Error --> X\n    \n    X -- Standardized Error --> Y[Log: Auth/Global Failed]\n    Y --> Z[Erreur Auth (Response 400/500)]",
        "height": 1136,
        "width": 608
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1104,
        256
      ],
      "typeVersion": 1,
      "id": "fcc01261-2ec6-4a28-8ea6-cb8ac5e8b62a",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "jsCode": "throw new Error($('Check Limit Init').first().json.error_to_throw);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        688,
        -432
      ],
      "id": "d4608612-1614-4ec8-bbcc-5cec9b84f6a5",
      "name": "Throw Error",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "throw new Error($('Check Limit Verify').first().json.error_to_throw);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        672,
        -208
      ],
      "id": "aed2c2da-a400-4c05-8b83-29c1bead4fad",
      "name": "Throw Error Verify",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "/* \n   🛡️ SECURITY GATEKEEPER \n   Ce nœud valide toutes les entrées avant qu'elles ne touchent la logique métier.\n*/\n\nconst body = $input.item.json.body || {};\nconst action = body.action;\nconst email = body.email;\n\n// 1. Validation de l'Action (Whitelist)\nconst ALLOWED_ACTIONS = ['auth-init', 'auth-verify', 'chat-message', 'refresh-token'];\nif (!ALLOWED_ACTIONS.includes(action)) {\n   throw new Error(`Action non autorisée ou inconnue: ${action}`);\n}\n\n// 2. Validation de l'Email (Seulement pour l'auth initiale/verif)\nif (['auth-init', 'auth-verify'].includes(action)) { // <--- CHANGEMENT ICI\n    const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$/;\n    if (!email || !emailRegex.test(email)) {\n       throw new Error(\"Format d'email invalide.\");\n    }\n}\n\n// 3. Validation OTP (Si verify)\nif (action === 'auth-verify') {\n    const code = body.code;\n    if (!code || !/^\\d{4}$/.test(code)) { // Doit être 4 chiffres exactement\n       throw new Error(\"Le code OTP doit être composé de 4 chiffres.\");\n    }\n}\n\n// 4. Validation Refresh Token\nif (action === 'refresh-token') {\n    if (!body.refreshToken || typeof body.refreshToken !== 'string' || body.refreshToken.length < 10) {\n        throw new Error(\"Refresh Token invalide.\");\n    }\n}\n\n// 5. Nettoyage basique (Sanitization)\n// On renvoie les données propres\nreturn {\n    ...body,\n    email: email ? email.toLowerCase().trim() : null, // Normalisation\n    _validated: true // Petit flag pour dire \"c'est validé\"\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -624,
        0
      ],
      "id": "4c125ad5-25dd-480b-9749-5db81a374a7e",
      "name": "Input Validation",
      "onError": "continueErrorOutput"
    }
  ],
  "pinData": {
    "Webhook (Entrée Unique)": [
      {
        "json": {
          "headers": {
            "host": "n8n.gehringer.fr",
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:146.0) Gecko/20100101 Firefox/146.0",
            "content-length": "68",
            "accept": "application/json, text/plain, */*",
            "accept-encoding": "gzip, br",
            "accept-language": "fr,fr-FR;q=0.8,en-US;q=0.5,en;q=0.3",
            "cdn-loop": "cloudflare; loops=1",
            "cf-connecting-ip": "82.64.157.46",
            "cf-ipcountry": "FR",
            "cf-ray": "9ae890ae5b99dec7-CDG",
            "cf-visitor": "{\"scheme\":\"https\"}",
            "cf-warp-tag-id": "67c37131-0032-4af7-9440-7b57888a89f7",
            "connection": "keep-alive",
            "content-type": "application/json",
            "origin": "http://localhost:4321",
            "priority": "u=0",
            "referer": "http://localhost:4321/",
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "cross-site",
            "sec-gpc": "1",
            "x-forwarded-for": "82.64.157.46",
            "x-forwarded-proto": "https"
          },
          "params": {},
          "query": {},
          "body": {
            "email": "fifoude@hotmail.com",
            "code": "6501",
            "action": "auth-verify"
          },
          "webhookUrl": "https://n8n.gehringer.fr/webhook/chat-api",
          "executionMode": "production"
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "connections": {
    "Webhook (Entrée Unique)": {
      "main": [
        [
          {
            "node": "Input Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router (Switch Action)": {
      "main": [
        [
          {
            "node": "Get Rate Limit Init",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Rate Limit Verify",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Hash Incoming Token",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Sécurité (Vérifier JWT)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Code OTP": {
      "main": [
        [
          {
            "node": "Sécu: Stocker Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vérifier Code (Mock)": {
      "main": [
        [
          {
            "node": "Supprimé Code Utilisé",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sécurité (Vérifier JWT)": {
      "main": [
        [
          {
            "node": "Log: Chat Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Whisper (STT)": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Réponse Init": {
      "main": [
        [
          {
            "node": "Send email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sécu: Stocker Code": {
      "main": [
        [
          {
            "node": "Réponse Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get stored OTP code": {
      "main": [
        [
          {
            "node": "Vérifier Code (Mock)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get CRM Contact": {
      "main": [
        [
          {
            "node": "Update CRM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update CRM": {
      "main": [
        [
          {
            "node": "Générer Code OTP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "Whisper (STT)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "Réponse Chat",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Get All Groups": {
      "main": [
        [
          {
            "node": "Merge Groups Names",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Google Contacts": {
      "main": [
        [
          {
            "node": "Get All Groups",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Groups Names": {
      "main": [
        [
          {
            "node": "Log: Auth Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Process Document": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router (Content Type)": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Process Document",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supprimé Code Utilisé": {
      "main": [
        [
          {
            "node": "Check Google Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Access Token": {
      "main": [
        [
          {
            "node": "Générer Refresh Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Refresh Token": {
      "main": [
        [
          {
            "node": "Sauvegarder Refresh Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sauvegarder Refresh Token": {
      "main": [
        [
          {
            "node": "Réponse Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log: Auth Success": {
      "main": [
        [
          {
            "node": "Générer Access Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log: Auth Failed": {
      "main": [
        [
          {
            "node": "Erreur Auth",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log: Chat Message": {
      "main": [
        [
          {
            "node": "Router (Content Type)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normaliseur d'Erreur": {
      "main": [
        [
          {
            "node": "Log: Auth Failed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hash Incoming Token": {
      "main": [
        [
          {
            "node": "Get Refresh Token Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Refresh Token Info": {
      "main": [
        [
          {
            "node": "Validate & Rotate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Rotate": {
      "main": [
        [
          {
            "node": "Delete Old Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Token": {
      "main": [
        [
          {
            "node": "Générer Access Token 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Access Token 1": {
      "main": [
        [
          {
            "node": "Générer Refresh Token 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Refresh Token 1": {
      "main": [
        [
          {
            "node": "Sauvegarder Refresh Token 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sauvegarder Refresh Token 1": {
      "main": [
        [
          {
            "node": "Réponse Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Rate Limit Init": {
      "main": [
        [
          {
            "node": "Check Limit Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Limit Init": {
      "main": [
        [
          {
            "node": "Update Rate Limit Init",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Update Rate Limit Init": {
      "main": [
        [
          {
            "node": "Block or Pass",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Rate Limit Verify": {
      "main": [
        [
          {
            "node": "Check Limit Verify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Limit Verify": {
      "main": [
        [
          {
            "node": "Update Rate Limit Verify",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Update Rate Limit Verify": {
      "main": [
        [
          {
            "node": "Block or Pass Verify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Block or Pass": {
      "main": [
        [
          {
            "node": "Throw Error",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get CRM Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Block or Pass Verify": {
      "main": [
        [
          {
            "node": "Throw Error Verify",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get stored OTP code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send email": {
      "main": [
        [],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Throw Error": {
      "main": [
        [],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Throw Error Verify": {
      "main": [
        [],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Input Validation": {
      "main": [
        [
          {
            "node": "Router (Switch Action)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Réponse Token": {
      "main": [
        []
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "2ee12524-89e7-4568-825e-4da24fe26da4",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "2194913e407b1e503ee1051e748fa0b50f28c847d89d91263b2430bdb12da207"
  },
  "id": "eBBXkB0vqJOsW6g8",
  "tags": []
}