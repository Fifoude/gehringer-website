{
  "name": "Backend Chat API",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chat-api",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "d797f36e-f8b9-4719-b5b6-bcad6107d764",
      "name": "Webhook (Entrée Unique)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -1792,
        848
      ],
      "webhookId": "d41783e1-c8f6-4aba-bd51-5016acb5582a"
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.action }}",
        "rules": {
          "rules": [
            {
              "value2": "auth-init"
            },
            {
              "value2": "auth-verify",
              "output": 1
            },
            {
              "value2": "chat-message",
              "output": 3
            },
            {
              "value2": "refresh-token",
              "output": 2
            }
          ]
        }
      },
      "id": "65cd214f-8468-4f61-97d8-4fcf5069f225",
      "name": "Router (Switch Action)",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [
        -1264,
        800
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\n// 1. Générer un code à 4 chiffres (pour l'utilisateur)\nconst code = Math.floor(1000 + Math.random() * 9000).toString();\n\n// 2. Créer le hash du code (pour la base de données)\n// On utilise SHA-256 qui est robuste\nconst codeHash = crypto.createHash('sha256').update(code).digest('hex');\n\n// Récupération sécurisée de l'email\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst email = body ? body.email : 'no-email-found';\n\nreturn {\n  email: email,\n  generated_code: code,      // NON-HASHÉ : À envoyer par email\n  code_hash: codeHash,       // HASHÉ : À stocker en DB\n  created_at: new Date().toISOString()\n};"
      },
      "id": "c6c9345e-1dee-4c65-a70c-23b76905664c",
      "name": "Générer Code OTP",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        432
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const crypto = require('crypto');\n\n// 1. Récupération des inputs\nconst webhook = $('Webhook (Entrée Unique)').first().json;\nconst email = webhook.body.email;\nconst receivedCode = String(webhook.body.code).trim(); // Le '1234' tapé par l'utilisateur\n\n// 2. Données stockées (HASHÉES)\nconst storedHash = $json.code; // Attention: la colonne s'appelle toujours 'code' mais contient le hash\nconst storedDate = $json.created_at;\nconst rowId = $json.id;\n\nif (!storedHash) {\n  throw new Error(\"Aucun OTP trouvé pour cet email.\");\n}\n\n// 3. Vérification de l'expiration (5 min)\nconst EXPIRATION_MS = 5 * 60 * 1000;\nconst now = new Date().getTime();\nconst createdAt = new Date(storedDate).getTime();\n\nif (now - createdAt > EXPIRATION_MS) {\n  throw new Error(\"Code OTP expiré. Veuillez en demander un nouveau.\");\n}\n\n// 4. HASHAGE ET COMPARAISON\n// On hashe le code reçu pour voir s'il correspond au hash stocké\nconst receivedCodeHash = crypto.createHash('sha256').update(receivedCode).digest('hex');\n\nif (receivedCodeHash !== storedHash) {\n  throw new Error(\"Code OTP invalide.\");\n}\n\n// 5. Succès\nreturn {\n  email,\n  valid: true,\n  rowIdToDelete: rowId\n};"
      },
      "id": "20b9c4b6-51b9-4905-a7ae-d8bdc7cc6948",
      "name": "Vérifier Code (Mock)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        384,
        640
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "operation": "verify",
        "token": "={{ $('Webhook (Entrée Unique)').item.json.headers.authorization.split(' ')[1] }}",
        "options": {}
      },
      "id": "d6538f68-b245-4d25-bd96-451fbf2ece8d",
      "name": "Sécurité (Vérifier JWT)",
      "type": "n8n-nodes-base.jwt",
      "typeVersion": 1,
      "position": [
        -912,
        1600
      ],
      "credentials": {
        "jwtAuth": {
          "id": "MSrsIWMcCZiwYCvf",
          "name": "JWT Auth account"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "Valide le jeton d'accès fourni par le chatbot. Extrait l'email et les labels de l'utilisateur (permissions) contenus dans le payload."
    },
    {
      "parameters": {
        "resource": "audio",
        "operation": "transcribe",
        "binaryPropertyName": "audio",
        "options": {}
      },
      "id": "90a665c6-9a83-4867-830e-8a1c619a8aa6",
      "name": "Whisper (STT)",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [
        96,
        1376
      ],
      "credentials": {
        "openAiApi": {
          "id": "pe1RxUmCYaJzcwAP",
          "name": "OpenAi account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "ee7e4b0f-b219-4cc9-80fd-61aef134d796",
      "name": "Réponse Init",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1296,
        432
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ \n  (() => {\n    // On cherche d'abord si la branche Login a produit quelque chose\n    let data = null;\n    try {\n        const loginItem = $('Générer Refresh Token').last(); \n        if (loginItem && loginItem.json && loginItem.json.accessToken) {\n            data = loginItem.json;\n        }\n    } catch (e) {}\n\n    // Si rien, on cherche dans la branche Refresh\n    if (!data) {\n        try {\n            const refreshItem = $('Générer Refresh Token 1').last();\n            if (refreshItem && refreshItem.json && refreshItem.json.accessToken) {\n                data = refreshItem.json;\n            }\n        } catch (e) {}\n    }\n\n    // Retourne le JSON stringifié (impératif pour ce champ)\n    if (data) {\n        return JSON.stringify({\n            accessToken: data.accessToken,\n            refreshToken: data.refreshToken\n        });\n    }\n    return JSON.stringify({ error: \"Tokens introuvables\" });\n  })()\n}}",
        "options": {}
      },
      "id": "ccdb0f7e-f07d-48d9-ac08-884bd78bcc90",
      "name": "Réponse Token",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1504,
        848
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { message: $json.text, output: $json.text, text: $json.text } }}",
        "options": {}
      },
      "id": "76111c16-5398-4a80-bdbe-00d49c3c8aff",
      "name": "Réponse Chat",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1840,
        1504
      ]
    },
    {
      "parameters": {
        "fromEmail": "contact@gehringer.fr",
        "toEmail": "={{ $json.email }}",
        "subject": "Your code",
        "html": "=Bonjour,\n\nvoici le code pour chatter: {{ $('Générer Code OTP').item.json.generated_code }}\n\nEn continuant, vous acceptez que votre email soit utilisé pour traiter votre demande.\n\nMerci !",
        "options": {
          "appendAttribution": false,
          "bccEmail": "philippe.lakas@gmail.com",
          "replyTo": "web.contact@gehringer.fr"
        }
      },
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        1488,
        432
      ],
      "id": "5a0586a3-4350-41cc-b940-db65c4a716a0",
      "name": "Send email",
      "webhookId": "25e76513-a504-43d5-9a46-87dc60e1b24a",
      "credentials": {
        "smtp": {
          "id": "IpKC6W2ftYil9cca",
          "name": "SMTP account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "IWWDAHh3QCefwYYN",
          "mode": "list",
          "cachedResultName": "OTP_Codes",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/IWWDAHh3QCefwYYN"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "code": "={{ $json.code_hash }}",
            "email": "={{ $json.email }}",
            "created_at": "={{ $json.created_at }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "code",
              "displayName": "code",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        896,
        432
      ],
      "id": "6d2468dc-7210-4660-aa85-3bc6020268fe",
      "name": "Sécu: Stocker Code"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "IWWDAHh3QCefwYYN",
          "mode": "list",
          "cachedResultName": "OTP_Codes",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/IWWDAHh3QCefwYYN"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        208,
        640
      ],
      "id": "438ff4c4-bfda-493d-84cf-7c35dbaff9b6",
      "name": "Get stored OTP code"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "yfw8czdVcKrGjiy1",
          "mode": "list",
          "cachedResultName": "CRM_Contacts",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/yfw8czdVcKrGjiy1"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        368,
        432
      ],
      "id": "8830d52d-e2f8-46c6-a5dc-8492edb4fd53",
      "name": "Get CRM Contact",
      "alwaysOutputData": true,
      "notes": "Est-ce que l'email existe ?"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "yfw8czdVcKrGjiy1",
          "mode": "list",
          "cachedResultName": "CRM_Contacts",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/yfw8czdVcKrGjiy1"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $('Webhook (Entrée Unique)').item.json.body.email }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "interaction_count": "={{ (Number($('Get CRM Contact').first().json.interaction_count) || 0) + 1 }}",
            "last_seen": "={{ new Date().toISOString() }}",
            "email": "={{ $('Webhook (Entrée Unique)').item.json.body.email }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "interaction_count",
              "displayName": "interaction_count",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "last_seen",
              "displayName": "last_seen",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        544,
        432
      ],
      "id": "67fabe05-1c43-4892-9252-ad9e5b4261e3",
      "name": "Update CRM",
      "notes": "Màj de CRM"
    },
    {
      "parameters": {
        "jsCode": "// Récupération chirurgicale du binaire depuis le Webhook initial\nconst binaryData = $('Webhook (Entrée Unique)').first().binary;\n\nreturn [{\n  json: items[0].json, // On garde le JSON courant (token, etc.)\n  binary: binaryData   // On réinjecte le binaire manquant\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        1392
      ],
      "id": "25e42bcc-525c-414c-8589-4377a650a7c2",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.text || $('Webhook (Entrée Unique)').item.json.body.text }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3,
      "position": [
        3536,
        1696
      ],
      "id": "eeffecec-f26c-4c74-ad1e-a017db26a5e1",
      "name": "AI Agent",
      "disabled": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4.1-nano",
          "mode": "list",
          "cachedResultName": "gpt-4.1-nano"
        },
        "builtInTools": {},
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        3536,
        1504
      ],
      "id": "75514fd6-99c3-4d14-84c5-f25187dfdd73",
      "name": "OpenAI Chat Model",
      "credentials": {
        "openAiApi": {
          "id": "pe1RxUmCYaJzcwAP",
          "name": "OpenAi account"
        }
      },
      "disabled": true
    },
    {
      "parameters": {
        "url": "https://people.googleapis.com/v1/contactGroups",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleContactsOAuth2Api",
        "options": {}
      },
      "id": "bc2655db-750e-4114-be78-407b14e14ee5",
      "name": "Get All Groups",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        624,
        832
      ],
      "credentials": {
        "googleContactsOAuth2Api": {
          "id": "xyMVAK068yLHLVtF",
          "name": "Google Contacts account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "https://people.googleapis.com/v1/people:searchContacts",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleContactsOAuth2Api",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "query",
              "value": "={{ $json.email }}"
            },
            {
              "name": "readMask",
              "value": "names,emailAddresses,memberships"
            }
          ]
        },
        "options": {}
      },
      "id": "f31aec25-6e81-48ff-8da5-314ff82d216d",
      "name": "Check Google Contacts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        448,
        832
      ],
      "alwaysOutputData": true,
      "retryOnFail": true,
      "credentials": {
        "googleContactsOAuth2Api": {
          "id": "xyMVAK068yLHLVtF",
          "name": "Google Contacts account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const response = $('Check Google Contacts').first().json;\n// The API returns { results: [ { person: { ... } } ] }\n// If no results, 'results' is undefined or empty\nconst person = (response.results && response.results.length > 0) ? response.results[0].person : {};\n\nconst groups = $('Get All Groups').first().json.contactGroups || [];\n\n// Create Map: resourceName -> formattedName\nconst groupMap = {};\ngroups.forEach(g => {\n  groupMap[g.resourceName] = g.formattedName;\n});\n\n// Extract User Memberships (safe access)\nconst rawMemberships = person.memberships || [];\n\nconst labels = rawMemberships.map(m => {\n   const resName = m.contactGroupMembership ? m.contactGroupMembership.contactGroupResourceName : null;\n   return groupMap[resName] || resName;\n}).filter(l => l != null);\n\n// Fallback email if contact not found\n// Note: original email input is needed if person.emailAddresses is empty\nconst verifiedEmail = $('Vérifier Code (Mock)').first().json.email;\nconst googleEmail = (person.emailAddresses && person.emailAddresses.length > 0) ? person.emailAddresses[0].value : null;\n\nreturn {\n  email: googleEmail || verifiedEmail,\n  user_labels: labels\n};"
      },
      "id": "862e0d38-c4cb-4a2c-81ef-a6fe6a083861",
      "name": "Merge Groups Names",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        832
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Webhook (Entrée Unique)').first().binary?.audio != null || ($('Webhook (Entrée Unique)').first().binary?.data?.mimeType?.startsWith('audio/') || false) }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "385fec2f-02e9-442e-adbd-e95283016e70"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "audio"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "000cf1d9-012c-456f-94e7-cc7ba22e7c01",
                    "leftValue": "={{ $('Webhook (Entrée Unique)').first().binary?.file != null || $('Webhook (Entrée Unique)').first().binary?.data != null }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "doc"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "401c868c-de35-47db-b16d-8deb7c3595cc",
      "name": "Router (Content Type)",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        -448,
        1584
      ],
      "notesInFlow": false,
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "operation": "deleteRows",
        "dataTableId": {
          "__rl": true,
          "value": "IWWDAHh3QCefwYYN",
          "mode": "list",
          "cachedResultName": "OTP_Codes",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/IWWDAHh3QCefwYYN"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyValue": "={{ $json.rowIdToDelete }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        544,
        640
      ],
      "id": "460a74cc-8ad3-49cc-8802-d757ec1417e9",
      "name": "Supprimé Code Utilisé"
    },
    {
      "parameters": {
        "useJson": true,
        "claimsJson": "={\n  \"expiresIn\": 900,\n  \"email\": \"{{ $('Vérifier Code (Mock)').first().json.email }}\",\n  \"user_labels\": \"{{ $('Merge Groups Names').item.json.user_labels }}\"\n}",
        "options": {}
      },
      "id": "a31bad8a-26dd-4bb2-8714-af1a77e39b4e",
      "name": "Générer Access Token",
      "type": "n8n-nodes-base.jwt",
      "typeVersion": 1,
      "position": [
        896,
        640
      ],
      "notesInFlow": true,
      "credentials": {
        "jwtAuth": {
          "id": "MSrsIWMcCZiwYCvf",
          "name": "JWT Auth account"
        }
      },
      "notes": "Token sert aux requêtes immédiates du chat"
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\n// 1. Récupérer l'Access Token généré juste avant (il est dans la propriété \"token\" ou la clé principale selon votre version)\n// Note: Le noeud JWT met souvent le résultat dans une propriété. Vérifiez l'input.\nconst accessToken = $json.token || $json; \nconst email = $('Vérifier Code (Mock)').first().json.email;\n\n// 2. Générer le Refresh Token (Opaque String)\nconst refreshToken = crypto.randomBytes(40).toString('hex');\n\n// 3. Calculer le Hash pour la base de données (SHA-256)\nconst tokenHash = crypto.createHash('sha256').update(refreshToken).digest('hex');\n\n// 4. Calculer la date d'expiration (+7 jours)\nconst expiry = new Date();\nexpiry.setDate(expiry.getDate() + 7);\n\nreturn {\n  email: email,\n  accessToken: accessToken,      // Le JWT court\n  refreshToken: refreshToken,    // Le secret à envoyer à l'utilisateur\n  tokenHash: tokenHash,          // Le hash à stocker\n  expiresAt: expiry.toISOString()\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1088,
        640
      ],
      "id": "72f4520d-3559-4b00-938d-c737c3598104",
      "name": "Générer Refresh Token"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "revoked": false,
            "email": "={{ $json.email }}",
            "token_hash": "={{ $json.tokenHash }}",
            "expires_at": "={{ $json.expiresAt }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "token_hash",
              "displayName": "token_hash",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "expires_at",
              "displayName": "expires_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "revoked",
              "displayName": "revoked",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {
          "optimizeBulk": false
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1296,
        640
      ],
      "id": "5d772c5c-5e64-4728-9f7c-00ceb72b8ac5",
      "name": "Sauvegarder Refresh Token"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "ytaFSb3YU5YIFY0q",
          "mode": "list",
          "cachedResultName": "Audit_Logs",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/ytaFSb3YU5YIFY0q"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{ new Date().toISOString() }}",
            "email": "={{ $json.email }}",
            "action": "=auth-verify",
            "status": "=success",
            "ip_address": "={{ $('Webhook (Entrée Unique)').first().json.headers['cf-connecting-ip'] || $('Webhook (Entrée Unique)').first().json.headers['x-forwarded-for'] }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "details",
              "displayName": "details",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": true
            },
            {
              "id": "ip_address",
              "displayName": "ip_address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        720,
        640
      ],
      "id": "bbee28bd-e9af-4931-a66b-b03198cf53e5",
      "name": "Log: Auth Success"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"error\": \"{{ $json.details.replace(/ \\[line \\d+\\]/, '') }}\"\n}",
        "options": {
          "responseCode": 400
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        1488,
        1088
      ],
      "id": "6438eff2-b7d1-4474-abec-ffa7e780258c",
      "name": "Erreur Auth"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "ytaFSb3YU5YIFY0q",
          "mode": "list",
          "cachedResultName": "Audit_Logs",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/ytaFSb3YU5YIFY0q"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{ new Date().toISOString() }}",
            "email": "={{ $('Webhook (Entrée Unique)').first().json.body.email }}",
            "action": "=auth-verify-fail",
            "status": "=error",
            "ip_address": "={{ $('Webhook (Entrée Unique)').first().json.headers['cf-connecting-ip'] }}",
            "details": "={{ $json.error }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "details",
              "displayName": "details",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "ip_address",
              "displayName": "ip_address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1296,
        1088
      ],
      "id": "be3fffed-1c67-416a-a7af-6deb6f1a23f3",
      "name": "Log: Auth Failed"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "ytaFSb3YU5YIFY0q",
          "mode": "list",
          "cachedResultName": "Audit_Logs",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/ytaFSb3YU5YIFY0q"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{ new Date().toISOString() }}",
            "email": "={{ $json.payload.email }}",
            "action": "=chat-message",
            "status": "=success",
            "ip_address": "={{ $('Webhook (Entrée Unique)').first().json.headers['cf-connecting-ip'] }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "details",
              "displayName": "details",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": true
            },
            {
              "id": "ip_address",
              "displayName": "ip_address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -688,
        1600
      ],
      "id": "9d9539c0-4b8b-4563-83b9-0e91ab60a73a",
      "name": "Log: Chat Message",
      "notes": "Enregistre la tentative de message dans la table Audit_Logs. Indispensable pour la traçabilité et le monitoring des usages par email et IP."
    },
    {
      "parameters": {
        "jsCode": "// Harmonise l'erreur quelle que soit sa source\nconst errorItem = $input.item.json;\nlet msg = errorItem.message || errorItem.error || \"Erreur inconnue\";\n\n// Nettoyage cosmétique\nmsg = msg.replace(/ \\[line \\d+\\]/, ''); \n\n// Détection du code HTTP suggéré\nlet status = 400;\nif (msg.includes('jwt expired') || msg.includes('token')) status = 401;\nif (msg.includes('connection') || msg.includes('timeout')) status = 503;\n\nreturn {\n  error: msg,  // Message propre pour l'utilisateur\n  raw_error: JSON.stringify(errorItem), // Pour les logs\n  http_status: status // Pour le nœud Response\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1104,
        1088
      ],
      "id": "935a72f5-fe01-43e1-8b39-87c3d7b1037c",
      "name": "Normaliseur d'Erreur"
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n// On s'assure d'avoir le token, qu'il vienne du body ou d'ailleurs\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst refreshToken = body.refreshToken;\n\nif (!refreshToken) {\n  throw new Error(\"Refresh Token manquant dans la requête.\");\n}\n\n// Hashage\nconst hash = crypto.createHash('sha256').update(refreshToken).digest('hex');\n\nreturn { \n  token_hash_to_find: hash,\n  original_token: refreshToken\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -736,
        1072
      ],
      "id": "0d20c489-00ba-43c1-9391-986295bbc505",
      "name": "Hash Incoming Token"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "token_hash",
              "keyValue": "={{ $json.token_hash_to_find }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -576,
        1072
      ],
      "id": "2c7cc506-96c0-4cb8-8df6-f342dea789fd",
      "name": "Get Refresh Token Info",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const storedToken = $input.item.json;\n\n// 1. Vérifications\nif (!storedToken || !storedToken.id) { // Si pas d'ID, c'est que rien n'a été trouvé\n   throw new Error(\"Refresh token introuvable ou invalide.\");\n}\n\nif (storedToken.revoked) {\n   throw new Error(\"Ce token a été révoqué.\");\n}\n\nconst expiresAt = new Date(storedToken.expires_at).getTime();\nif (Date.now() > expiresAt) {\n   throw new Error(\"Refresh token expiré (Session terminée).\");\n}\n\n// 2. Préparer la suite (On renvoie l'email pour le futur JWT)\nreturn {\n   email: storedToken.email,\n   oldTokenId: storedToken.id // ID à supprimer pour la rotation\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -400,
        1072
      ],
      "id": "31211445-5d81-46f8-bb85-6fb8dd192ad9",
      "name": "Validate & Rotate"
    },
    {
      "parameters": {
        "operation": "deleteRows",
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "filters": {
          "conditions": [
            {
              "keyValue": "={{ $json.oldTokenId }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -224,
        1072
      ],
      "id": "6bdb6fae-259d-466e-83a9-4fc7f64ef2a4",
      "name": "Delete Old Token"
    },
    {
      "parameters": {
        "useJson": true,
        "claimsJson": "={\n  \"expiresIn\": 900,\n  \"email\": \"{{ $json.email }}\",\n  \"user_labels\": \"{{ $json.user_labels || [] }}\"\n}",
        "options": {}
      },
      "id": "8de16d09-5632-464b-8af6-2f0f56f4bd9a",
      "name": "Générer Access Token 1",
      "type": "n8n-nodes-base.jwt",
      "typeVersion": 1,
      "position": [
        -16,
        1072
      ],
      "notesInFlow": true,
      "credentials": {
        "jwtAuth": {
          "id": "MSrsIWMcCZiwYCvf",
          "name": "JWT Auth account"
        }
      },
      "notes": "Token sert aux requêtes immédiates du chat"
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\n// 1. Récupérer l'Access Token généré juste avant (il est dans la propriété \"token\" ou la clé principale selon votre version)\n// Note: Le noeud JWT met souvent le résultat dans une propriété. Vérifiez l'input.\nconst accessToken = $json.token || $json; \nconst email = $('Vérifier Code (Mock)').first().json.email;\n\n// 2. Générer le Refresh Token (Opaque String)\nconst refreshToken = crypto.randomBytes(40).toString('hex');\n\n// 3. Calculer le Hash pour la base de données (SHA-256)\nconst tokenHash = crypto.createHash('sha256').update(refreshToken).digest('hex');\n\n// 4. Calculer la date d'expiration (+7 jours)\nconst expiry = new Date();\nexpiry.setDate(expiry.getDate() + 7);\n\nreturn {\n  email: email,\n  accessToken: accessToken,      // Le JWT court\n  refreshToken: refreshToken,    // Le secret à envoyer à l'utilisateur\n  tokenHash: tokenHash,          // Le hash à stocker\n  expiresAt: expiry.toISOString()\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        1072
      ],
      "id": "83a7ffb4-63cd-449e-81b6-7ee719c08f71",
      "name": "Générer Refresh Token 1"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "revoked": false,
            "email": "={{ $json.email }}",
            "token_hash": "={{ $json.tokenHash }}",
            "expires_at": "={{ $json.expiresAt }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "token_hash",
              "displayName": "token_hash",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "expires_at",
              "displayName": "expires_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "revoked",
              "displayName": "revoked",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        384,
        1072
      ],
      "id": "e0cea412-e9b4-4c7b-9c87-757ccb53dc4b",
      "name": "Sauvegarder Refresh Token 1"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "=auth-init"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -784,
        432
      ],
      "id": "7f9e3d6b-51e3-42f9-a83d-6cc7949f5e42",
      "name": "Get Rate Limit Init",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const limit = $input.item.json; // Résultat de la DB\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst email = body.email;\nconst now = new Date();\n\n// Configuration\nconst MAX_ATTEMPTS = 3;\nconst WINDOW_MINUTES = 15;\nconst BLOCK_MINUTES = 30;\n\nlet newCount = 1;\nlet firstDates = now.toISOString();\nlet blockedUntil = null;\nlet errorMessage = null; // Variable pour stocker l'erreur potentielle\n\n// Vérifier si déjà un enregistrement\nif (limit.id) {\n  // 1. Est-il DÉJÀ bloqué ?\n  if (limit.blocked_until && new Date(limit.blocked_until) > now) {\n     const minutesLeft = Math.ceil((new Date(limit.blocked_until) - now) / 60000);\n     errorMessage = `Trop de tentatives. Réessayez dans ${minutesLeft} minutes.`;\n     // On garde les anciennes valeurs pour ne pas les écraser\n     newCount = limit.count;\n     firstDates = limit.first_attempt_at;\n     blockedUntil = limit.blocked_until;\n     \n  } else {\n      // 2. Vérification de la fenêtre de temps\n      const firstAttempt = new Date(limit.first_attempt_at);\n      const diffMinutes = (now - firstAttempt) / 60000;\n\n      if (diffMinutes > WINDOW_MINUTES) {\n         // Fenêtre expirée, on reset tout\n         newCount = 1;\n         firstDates = now.toISOString();\n         blockedUntil = null;\n      } else {\n         // Dans la fenêtre, on incrémente\n         newCount = (limit.count || 0) + 1;\n         firstDates = limit.first_attempt_at;\n         \n         if (newCount > MAX_ATTEMPTS) {\n            // On bloque MAINTENANT\n            const blockDate = new Date(now.getTime() + BLOCK_MINUTES * 60000);\n            blockedUntil = blockDate.toISOString();\n            errorMessage = \"Trop de demandes de code. Compte bloqué 30 min.\";\n         }\n      }\n  }\n}\n\nreturn {\n   email: email,\n   action: 'auth-init', // Rappel : Mettre 'auth-verify' pour l'autre branche\n   count: newCount,\n   first_attempt_at: firstDates,\n   blocked_until: blockedUntil,\n   error_to_throw: errorMessage // LA clé magique\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        432
      ],
      "id": "9f7d6709-1842-4072-af90-169bce77d4d1",
      "name": "Check Limit Init"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "={{ $json.action }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "count": "={{ $json.count }}",
            "email": "={{ $json.email }}",
            "action": "={{ $json.action }}",
            "first_attempt_at": "={{ $json.first_attempt_at }}",
            "blocked_until": "={{ $json.blocked_until }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "count",
              "displayName": "count",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "first_attempt_at",
              "displayName": "first_attempt_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "blocked_until",
              "displayName": "blocked_until",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -432,
        432
      ],
      "id": "dd9135e4-319e-4cdf-a4bd-886a6bdf0800",
      "name": "Update Rate Limit Init"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "=auth-verify"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -784,
        656
      ],
      "id": "e7ca282b-5380-4597-a9d9-d89583369dae",
      "name": "Get Rate Limit Verify",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const limit = $input.item.json; // Résultat de la DB\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst email = body.email;\nconst now = new Date();\n\n// Configuration SPECIFIQUE 'Verify'\nconst MAX_ATTEMPTS = 5;      // 5 essais\nconst WINDOW_MINUTES = 5;    // En 5 minutes\nconst BLOCK_MINUTES = 30;    // Blocage 30 min\n\nlet newCount = 1;\nlet firstDates = now.toISOString();\nlet blockedUntil = null;\nlet errorMessage = null;\n\n// Vérifier si déjà un enregistrement\nif (limit.id) {\n  // 1. Est-il DÉJÀ bloqué ?\n  if (limit.blocked_until && new Date(limit.blocked_until) > now) {\n     const minutesLeft = Math.ceil((new Date(limit.blocked_until) - now) / 60000);\n     errorMessage = `Compte bloqué. Réessayez dans ${minutesLeft} minutes.`;\n     newCount = limit.count;\n     firstDates = limit.first_attempt_at;\n     blockedUntil = limit.blocked_until;\n     \n  } else {\n      // 2. Vérification de la fenêtre de temps\n      const firstAttempt = new Date(limit.first_attempt_at);\n      const diffMinutes = (now - firstAttempt) / 60000;\n\n      if (diffMinutes > WINDOW_MINUTES) {\n         // Fenêtre expirée, on reset\n         newCount = 1;\n         firstDates = now.toISOString();\n         blockedUntil = null;\n      } else {\n         // Dans la fenêtre, on incrémente\n         newCount = (limit.count || 0) + 1;\n         firstDates = limit.first_attempt_at;\n         \n         if (newCount > MAX_ATTEMPTS) {\n            // On bloque MAINTENANT\n            const blockDate = new Date(now.getTime() + BLOCK_MINUTES * 60000);\n            blockedUntil = blockDate.toISOString();\n            errorMessage = \"Trop d'essais incorrects. Compte bloqué 30 min.\";\n         }\n      }\n  }\n}\n\nreturn {\n   email: email,\n   action: 'auth-verify', // Important : c'est l'action 'verify' ici\n   count: newCount,\n   first_attempt_at: firstDates,\n   blocked_until: blockedUntil,\n   error_to_throw: errorMessage\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        656
      ],
      "id": "7441455d-d889-43ee-b8c7-e33dac247923",
      "name": "Check Limit Verify"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "={{ $json.action }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "count": "={{ $json.count }}",
            "email": "={{ $json.email }}",
            "action": "={{ $json.action }}",
            "first_attempt_at": "={{ $json.first_attempt_at }}",
            "blocked_until": "={{ $json.blocked_until }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "count",
              "displayName": "count",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "first_attempt_at",
              "displayName": "first_attempt_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "blocked_until",
              "displayName": "blocked_until",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -432,
        656
      ],
      "id": "c1249ffd-1796-4eeb-b14a-d1e820fec95f",
      "name": "Update Rate Limit Verify"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "02fd86a9-959e-4873-9517-4fa10b9b33e0",
              "leftValue": "={{ $('Check Limit Init').first().json.error_to_throw }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -224,
        432
      ],
      "id": "408bf7fc-31ad-4058-b448-6044d40f0526",
      "name": "Block or Pass"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "10a2a8e3-7539-46f0-89fd-e1f9b1673715",
              "leftValue": "={{ $('Check Limit Verify').first().json.error_to_throw }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -224,
        656
      ],
      "id": "4cf41634-7d1b-4fd5-ae67-05282080e471",
      "name": "Block or Pass Verify"
    },
    {
      "parameters": {
        "content": "## Gestion des erreurs (à peaufiner)\n(Si votre variable s'appelle $json.error ou $json.message, adaptez juste le début. Le .replace(...) est standard).\n\n2. Centraliser la gestion des erreurs (Branche \"Catch-All\")\nAbsolument ! C'est même une \"best practice\" en architecture n8n appelée le pattern Error Workflow ou Error Trigger.\n\nMais sans créer un workflow séparé complexe, vous pouvez tout à fait connecter plusieurs nœuds à votre branche d'erreur existante.\n\nComment ça marche ? Pour chaque nœud critique, vous allez dans ses Settings -> On Error -> Continue (using error output). Cela fait apparaître la 2ème sortie (grise/rouge). Vous tirez ensuite un fil de cette sortie vers l'entrée de votre branche \"Erreur\" (le nœud Log: Auth Failed ou directement Erreur Auth).\n\nListe des nœuds à connecter (suggérés) :\n\nSécurité (Vérifier JWT) : ESSENTIEL.\nSi le token est expiré ou invalide, cela plante le workflow. En le connectant à Erreur Auth, l'utilisateur recevra un propre 401/400 et le Frontend pourra (comme on l'a codé hier) lui dire \"Session expirée\".\nNote : Modifiez le message d'erreur dans Erreur Auth pour gérer le cas spécifique (ex: si le message contient \"jwt expired\", renvoyer un code HTTP 401).\nCheck Google Contacts (HTTP Request) :\nSi l'API Google est en panne ou rejette la requête (quota, erreur 500), le workflow s'arrête.\nConnectez-le pour dire \"Service temporairement indisponible\".\nWhisper (STT) & OpenAI Chat Model :\nSi OpenAI est down ou timeout, c'est critique de prévenir l'utilisateur (\"L'IA ne répond pas pour le moment\").\nSend Email :\nSi le SMTP échoue, l'utilisateur attend son code pour rien. Il vaut mieux lui dire \"Impossible d'envoyer l'email, réessayez\".\nAttention à la structure du JSON d'erreur ! Quand un nœud plante, il sort un JSON qui ressemble souvent à :\n\njson\n{\n  \"message\": \"Error description\",\n  \"name\": \"NodeApiError\",\n  ...\n}\nVotre nœud Log: Auth Failed attend actuellement un champ bien précis pour le details. L'astuce est d'insérer un petit nœud Code (ou \"Edit Fields\") juste au début de votre branche erreur commune qui normalise tout ça :\n\nArchitecture Recommandée :\n\nmermaid\ngraph TD\n    A[Vérifier Code] -- Error --> X[Normaliseur d'Erreur]\n    B[Vérifier JWT] -- Error --> X\n    C[OpenAI] -- Error --> X\n    \n    X -- Standardized Error --> Y[Log: Auth/Global Failed]\n    Y --> Z[Erreur Auth (Response 400/500)]",
        "height": 1136,
        "width": 608
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1792,
        1104
      ],
      "typeVersion": 1,
      "id": "ae2d7de0-4a4a-481f-bf2c-7547f42fb2fd",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "jsCode": "throw new Error($('Check Limit Init').first().json.error_to_throw);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        416
      ],
      "id": "06ada840-bff9-4d3c-af42-e7f0ceb030f8",
      "name": "Throw Error",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "throw new Error($('Check Limit Verify').first().json.error_to_throw);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -16,
        640
      ],
      "id": "bf3a4126-7390-4f58-800f-b6c90dd3c221",
      "name": "Throw Error Verify",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "/* \n   🛡️ SECURITY GATEKEEPER \n   Ce nœud valide toutes les entrées avant qu'elles ne touchent la logique métier.\n*/\n\nconst body = $input.item.json.body || {};\nconst action = body.action;\nconst email = body.email;\n\n// 1. Validation de l'Action (Whitelist)\nconst ALLOWED_ACTIONS = ['auth-init', 'auth-verify', 'chat-message', 'refresh-token'];\nif (!ALLOWED_ACTIONS.includes(action)) {\n   throw new Error(`Action non autorisée ou inconnue: ${action}`);\n}\n\n// 2. Validation de l'Email (Seulement pour l'auth initiale/verif)\nif (['auth-init', 'auth-verify'].includes(action)) { // <--- CHANGEMENT ICI\n    const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$/;\n    if (!email || !emailRegex.test(email)) {\n       throw new Error(\"Format d'email invalide.\");\n    }\n}\n\n// 3. Validation OTP (Si verify)\nif (action === 'auth-verify') {\n    const code = body.code;\n    if (!code || !/^\\d{4}$/.test(code)) { // Doit être 4 chiffres exactement\n       throw new Error(\"Le code OTP doit être composé de 4 chiffres.\");\n    }\n}\n\n// 4. Validation Refresh Token\nif (action === 'refresh-token') {\n    if (!body.refreshToken || typeof body.refreshToken !== 'string' || body.refreshToken.length < 10) {\n        throw new Error(\"Refresh Token invalide.\");\n    }\n}\n\n// 5. Nettoyage basique (Sanitization)\n// On renvoie les données propres\nreturn {\n    ...body,\n    email: email ? email.toLowerCase().trim() : null, // Normalisation\n    _validated: true // Petit flag pour dire \"c'est validé\"\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1552,
        848
      ],
      "id": "10b4106e-040c-48d0-acfc-9cbac783dc43",
      "name": "Input Validation",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Récupération du binaire depuis le Webhook initial\nconst webhookBinary = $('Webhook (Entrée Unique)').first().binary;\n\n// On vérifie s'il y a du binaire (peu importe la clé : file, data, attachment...)\nconst keys = Object.keys(webhookBinary || {});\nif (keys.length === 0) {\n  throw new Error(\"Erreur interne : Le fichier a été perdu en cours de route.\");\n}\n\n// On standardise la clé à 'data' pour le Subworkflow (Extract Text attend 'data' par défaut)\nconst binaryData = webhookBinary[keys[0]];\n\nreturn [{\n  json: items[0].json,\n  binary: {\n    data: binaryData\n  }\n}];"
      },
      "id": "948a553f-f59d-488f-a73e-4270bd4f7f09",
      "name": "Restore Binary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -208,
        1792
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "wc1gPl32rku4ikBN",
          "mode": "list",
          "cachedResultUrl": "/workflow/wc1gPl32rku4ikBN",
          "cachedResultName": "Subworkflow - File Gatekeeper"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "f82a24cc-e6d3-4189-809b-26ec66014cbe",
      "name": "File Gatekeeper",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        96,
        1808
      ]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://ollama:11434/api/generate",
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "model",
              "value": "gemma2:2b"
            },
            {
              "name": "prompt",
              "value": "=Tu es un routeur intelligent spécialisé pour un assistant professionnel (Gehringer).\nAnalyse l'entrée utilisateur et décide si elle nécessite une recherche dans la base de connaissances (RAG) ou si c'est une simple discussion (CHAT).\n\nCRITÈRES DE DÉCISION :\n- INTENT \"rag\" : Uniquement si la question porte sur des aspects professionnels spécifiques comme :\n- L'analyse d'un profil par rapport à un poste (matching).\n- Des questions sur des missions, des offres d'emploi ou des opportunités.\n- Une demande de CV ou de parcours professionnel.\n- L'analyse du contenu d'un document joint.\n\n- INTENT \"chat\" : Pour tout le reste, y compris :\n- Salutations (\"Bonjour\", \"Ça va ?\").\n- Questions générales, culturelles ou météo (\"Quelle est la météo à Paris ?\").\n- Discussions sans lien direct avec le recrutement ou les documents joints.\n\nContexte : {{$json.file_metadata ? 'Fichier joint' : 'Aucun fichier'}}\nEntrée : {{ $json.text || $json.ocr_text || $('Webhook (Entrée Unique)').item.json.body.text || $('Webhook (Entrée Unique)').item.json.body.message }}\n\nRéponds UNIQUEMENT au format JSON strict :\n{ \"intent\": \"rag\" | \"chat\", \"reason\": \"...\" }"
            },
            {
              "name": "format",
              "value": "json"
            },
            {
              "name": "stream",
              "value": false
            }
          ]
        },
        "options": {}
      },
      "id": "0f1289dd-adb8-487d-9ec1-fd5836e70019",
      "name": "Router Ollama",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        3664,
        2240
      ],
      "disabled": true
    },
    {
      "parameters": {
        "jsCode": "/* \n  CONTEXT MERGER (Audit-Fix)\n  Sépare le texte saisi de la retranscription binaire et ajoute l'email.\n*/\n\nconst data = $input.first().json;\nlet webhookBody = {}; \ntry { webhookBody = $('Webhook (Entrée Unique)').first().json.body || {}; } catch(e){}\n\n// 1. Extraction de l'Email et des Labels depuis le JWT\nlet email = \"no-email\";\nlet userLabels = [];\ntry {\n   const jwtPayload = $('Sécurité (Vérifier JWT)').first().json.payload;\n   email = jwtPayload.email || \"no-email\";\n   if(jwtPayload.user_labels) {\n       userLabels = Array.isArray(jwtPayload.user_labels) ? jwtPayload.user_labels : jwtPayload.user_labels.split(',');\n   }\n} catch(e) {}\n\n// 2. Distinction des entrées\n// Text saisi par l'utilisateur (Inline)\nconst user_text = webhookBody.text || webhookBody.chatInput || webhookBody.message || \"\";\n\n// Contenu extrait des médias (Audio ou PDF)\nconst file_text = data.transcription || data.text || \"\"; \n\n// 3. Construction du chatInput final (pour compatibilité descendante)\n// On combine proprement si les deux existent\nlet combinedQuery = user_text;\nif (file_text && file_text !== user_text) {\n    combinedQuery = user_text ? `${user_text}\\n\\n[Contenu du document/audio]:\\n${file_text}` : file_text;\n}\n\nreturn [{\n  json: {\n    email,\n    user_labels: userLabels,\n    text_input: user_text,\n    media_transcription: file_text,\n    chatInput: combinedQuery,\n    sessionId: webhookBody.sessionId || \"no-session\",\n    processedAt: new Date().toISOString()\n  }\n}];"
      },
      "id": "562a4dde-c2b0-4658-a191-f99de9e1116a",
      "name": "Context Merger",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        1552
      ]
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.intent }}",
        "rules": {
          "rules": [
            {
              "value2": "chat"
            },
            {
              "value2": "rag",
              "output": 1
            }
          ]
        }
      },
      "id": "a89d4fea-95ac-4f92-a506-5253780cb308",
      "name": "Router (Switch Intent)",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [
        3088,
        1680
      ],
      "disabled": true
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "Yw18E2lgZziMH8uX",
          "mode": "list",
          "cachedResultUrl": "/workflow/Yw18E2lgZziMH8uX",
          "cachedResultName": "Unified RAG Chat & PDF Generator"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "ece14a36-c629-45e5-9664-815ec4a39149",
      "name": "Workflow RAG",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        3424,
        2208
      ],
      "disabled": true
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 3
                },
                "conditions": [
                  {
                    "leftValue": "={{ $json.pdf_generated }}",
                    "rightValue": "=true",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "06a82771-4192-426f-85c9-bccc1481b395"
                  }
                ],
                "combinator": "and"
              }
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3.4,
      "position": [
        3600,
        1952
      ],
      "id": "67614a42-da47-4cbd-9147-771c0b86c380",
      "name": "Is PDF?",
      "disabled": true
    },
    {
      "parameters": {
        "fromEmail": "contact@gehringer.fr",
        "toEmail": "={{ $('Router (Switch Intent)').item.json.email }}",
        "subject": "Votre document Gehringer Conseil",
        "html": "=Bonjour,\n\nBonjour, veuillez trouver ci-joint votre document...\nMerci !",
        "options": {
          "appendAttribution": false,
          "attachments": "data",
          "bccEmail": "philippe.lakas@gmail.com",
          "replyTo": "web.contact@gehringer.fr"
        }
      },
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        3856,
        1872
      ],
      "id": "dc31ff01-53c0-42cf-ad68-ad42d3c9ded2",
      "name": "Send email1",
      "webhookId": "25e76513-a504-43d5-9a46-87dc60e1b24a",
      "credentials": {
        "smtp": {
          "id": "IpKC6W2ftYil9cca",
          "name": "SMTP account"
        }
      },
      "disabled": true,
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "content": "# Entrée et Audit",
        "height": 272,
        "width": 448
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -976,
        1520
      ],
      "typeVersion": 1,
      "id": "0bd8dc5c-d7f0-4482-b49b-d428c3669ae7",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "sk0XdwzdY0Zk_ZM-Pso2Z",
          "mode": "list",
          "cachedResultUrl": "/workflow/sk0XdwzdY0Zk_ZM-Pso2Z",
          "cachedResultName": "Philippe AI Brain (Central - Final Fix)"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {
          "waitForSubWorkflow": true
        }
      },
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        1600,
        1504
      ],
      "id": "05e52a67-fa99-4056-bfa6-1fbbbbb26887",
      "name": "Call 'Philippe AI Brain (Central - Final Fix)'"
    },
    {
      "parameters": {
        "text": "={{ $json.chatInput }}",
        "guardrails": {
          "topicalAlignment": {
            "value": {
              "threshold": 0.6,
              "prompt": "Vous êtes un système d'analyse de contenu qui détermine si un texte reste dans le périmètre autorisé.\n\nPÉRIMÈTRE AUTORISÉ :\n1. Questions professionnelles concernant :\n   - L'entreprise Gehringer\n   - Philippe Gehringer (compétences, services, expérience)\n   - Les services proposés par l'entreprise\n   \n2. Messages de politesse :\n   - Salutations (bonjour, bonsoir, hello)\n   - Remerciements (merci, thanks)\n   - Formules de politesse (au revoir, à bientôt)\n\nHORS PÉRIMÈTRE (à bloquer) :\n- Actualités générales\n- Cuisine, recettes\n- Sport, divertissement\n- Politique\n- Santé personnelle\n- Tout sujet non lié à Gehringer/Philippe ou aux services\n\nDéterminez si le texte respecte le périmètre autorisé."
            }
          }
        }
      },
      "id": "guardrail-topic-filter",
      "name": "Guardrail - Topic Filter",
      "type": "@n8n/n8n-nodes-langchain.guardrails",
      "typeVersion": 2,
      "position": [
        2928,
        1952
      ],
      "disabled": true,
      "notes": "🛡️ Niveau 1 : Filtrage des sujets hors périmètre professionnel"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o-mini",
          "mode": "list",
          "cachedResultName": "gpt-4o-mini"
        },
        "builtInTools": {},
        "options": {
          "maxTokens": 500,
          "temperature": 0.3
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        2928,
        2192
      ],
      "id": "1417ae0b-4243-4afb-b315-71672f3029b1",
      "name": "OpenAI Chat Model1",
      "credentials": {
        "openAiApi": {
          "id": "pe1RxUmCYaJzcwAP",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/* \n  CONTEXT MERGER (Corrigé)\n  Récupère le message peu importe son nom.\n*/\n\n// Références aux nœuds\nconst data = $input.first().json;\nlet webhookBody = {};\ntry { webhookBody = $('Webhook (Entrée Unique)').first().json.body || {}; } catch(e){}\nlet inputValidation = {};\ntry { inputValidation = $('Input Validation').first().json || {}; } catch(e){}\n\n// LISTE DES CANDIDATS (Ordre de priorité)\n// On a ajouté 'text' venant du body du webhook, c'est celui qu'on a vu sur la capture.\nconst candidates = [\n  // 1. Inputs directs (votre Routeur ou Whisper)\n  data.text, data.transcription, data.chatInput, \n  \n  // 2. Input Validation (s'il normalise)\n  inputValidation.chatInput, inputValidation.text,\n  \n  // 3. Webhook Source (La vérité nue)\n  webhookBody.text,        // <--- C'EST CELUI-LA QU'ON VEUT !\n  webhookBody.chatInput, \n  webhookBody.message\n];\n\n// Trouver le premier non-vide\nlet finalQuery = candidates.find(c => c && typeof c === 'string' && c.trim() !== \"\") || \"\";\n\n// Récupération Session\nconst sessionId = data.sessionId || inputValidation.sessionId || webhookBody.sessionId || \"no-session\";\n\nreturn [\n  {\n    json: {\n      chatInput: finalQuery, // Sera \"Bonjour, qui es-tu ?\"\n      sessionId: sessionId,\n      processedAt: new Date().toISOString()\n    }\n  }\n];"
      },
      "id": "3c587d56-750c-4f5c-955c-dc007911f9ac",
      "name": "Context Merger old",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        3136,
        2192
      ],
      "disabled": true
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.openai.com/v1/chat/completions",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "openAiApi",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={{ JSON.stringify({ model: 'gpt-4o-mini', messages: [ { role: 'system', content: \"Tu es un contrôleur d'accès. Analyse l'entrée utilisateur.\\n\\nGUIDE DE CLASSIFICATION :\\n1. 'pro': Sujets Gehringer, Recrutement, Management de transition, Compétences de Philippe, ou Politesse basique (Bonjour, Merci).\\n2. 'shadow': Sujets Appartement, Wifi, Clés, Code d'entrée, Infos privées.\\n   -> CONDITION: L'utilisateur DOIT avoir le tag 'Airbnb', 'Ami', ou 'Famille'.\\n   -> Si les droits sont absents, classer en 'blocked'.\\n3. 'blocked': Météo, Politique, Sport, Recettes, blagues génériques, ou Shadow sans droits.\\n\\nRéponds UNIQUEMENT le JSON : { \\\"category\\\": \\\"pro\\\" | \\\"shadow\\\" | \\\"blocked\\\" }\" }, { role: 'user', content: 'Message: ' + $json.chatInput + '\\nTags: ' + $json.user_labels } ], temperature: 0 }) }}",
        "options": {}
      },
      "id": "9b49dc3d-ccb3-4267-a573-a82ac9495360",
      "name": "Rights Analyzer",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        736,
        1552
      ],
      "credentials": {
        "openAiApi": {
          "id": "pe1RxUmCYaJzcwAP",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "let analysis = { category: 'blocked' };\ntry {\n  const content = $json.choices[0].message.content;\n  // Nettoyage markdown json si présent\n  const cleanJson = content.replace(/```json/g, '').replace(/```/g, '').trim();\n  analysis = JSON.parse(cleanJson);\n} catch(e) {}\n\n// RECUPERATION DU CONTEXTE ORIGINAL\n// On reprend tout ce qui sortait du Context Merger (chatInput, user_labels, sessionId...)\nconst originalContext = $('Context Merger').first().json;\n\nreturn [{\n  json: {\n    ...originalContext,\n    rights_category: analysis.category\n  }\n}];"
      },
      "id": "09e6d275-076d-462d-9e36-aef7465591a6",
      "name": "Parse Rights",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        928,
        1552
      ]
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.rights_category }}",
        "rules": {
          "rules": [
            {
              "value2": "pro"
            },
            {
              "value2": "shadow",
              "output": 1
            },
            {
              "value2": "blocked",
              "output": 2
            }
          ]
        }
      },
      "id": "9c454b2e-97f9-44e7-8d7c-da74acd34dd7",
      "name": "Router (User Rights)",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [
        1168,
        1520
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"output\": \"Désolé, je ne peux pas traiter votre demande. Je suis exclusivement dédié aux échanges professionnels concernant les activités de Philippe Gehringer.\"\n}",
        "options": {}
      },
      "id": "ed95923f-eafc-41fb-abab-b57039f5123c",
      "name": "Rejection Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1840,
        1888
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "{\n \"text\": \"[🗝️ MODE PRIVÉ ACTIVÉ]\\n\\nBonjour ! Je vois que vous faites partie des invités privilégiés (Airbnb/Ami).\\n\\nVoici ce que je peux faire pour vous :\\n- Vous donner le code Wifi\\n- Vous expliquer comment récupérer les clés\\n- Vous indiquer où se trouvent les poubelles...\\n\\nQue souhaitez-vous savoir ?\"\n}",
        "options": {}
      },
      "id": "c0c0a082-b3f5-47f9-b3c0-52b26f1020a7",
      "name": "Shadow Brain Response",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1840,
        1712
      ]
    },
    {
      "parameters": {
        "content": "# Traitement selon type de contenant\n## Accepte inline, audio & pdf",
        "height": 720,
        "width": 1120,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -496,
        1280
      ],
      "typeVersion": 1,
      "id": "b217401d-6145-46f3-bde5-8d9d89c4d2aa",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "content": "# Triage selon contenu\n## Différents brains\n",
        "height": 368,
        "width": 704,
        "color": 4
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        688,
        1424
      ],
      "typeVersion": 1,
      "id": "4acc5b96-bc8e-4afc-bd6e-a1277c7de7a7",
      "name": "Sticky Note3"
    }
  ],
  "pinData": {
    "Webhook (Entrée Unique)": [
      {
        "json": {
          "headers": {
            "host": "n8n.gehringer.fr",
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36",
            "content-length": "384647",
            "accept": "application/json, text/plain, */*",
            "accept-encoding": "gzip, br",
            "accept-language": "en-US,en;q=0.9,fr;q=0.8",
            "authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHBpcmVzSW4iOjkwMCwiZW1haWwiOiJmaWZvdWRlQGhvdG1haWwuY29tIiwidXNlcl9sYWJlbHMiOiIiLCJpYXQiOjE3Njg0MjY3OTd9.wso_zS1ecZHkyTPTzZ4kLYh-qt8e8WEU3Md41d9ZPoI",
            "cdn-loop": "cloudflare; loops=1",
            "cf-connecting-ip": "2a01:e0a:183:7c60:7d4e:2fb1:d5bd:4a82",
            "cf-ipcountry": "FR",
            "cf-ray": "9bed040428c80279-CDG",
            "cf-visitor": "{\"scheme\":\"https\"}",
            "cf-warp-tag-id": "b58e200c-9718-4899-9cc5-972a6e49f296",
            "connection": "keep-alive",
            "content-type": "multipart/form-data; boundary=----WebKitFormBoundarynEBRBpWXWOeBWQH9",
            "origin": "http://localhost:4321",
            "priority": "u=1, i",
            "referer": "http://localhost:4321/",
            "sec-ch-ua": "\"Google Chrome\";v=\"143\", \"Chromium\";v=\"143\", \"Not A(Brand\";v=\"24\"",
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": "\"Windows\"",
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "cross-site",
            "x-forwarded-for": "2a01:e0a:183:7c60:7d4e:2fb1:d5bd:4a82",
            "x-forwarded-proto": "https"
          },
          "params": {},
          "query": {},
          "body": {
            "action": "chat-message",
            "history": "[]"
          },
          "webhookUrl": "https://n8n.gehringer.fr/webhook/chat-api",
          "executionMode": "production"
        },
        "binary": {
          "file": {
            "mimeType": "application/pdf",
            "fileType": "pdf",
            "fileExtension": "pdf",
            "data": "filesystem-v2",
            "fileName": "Offre Emploi CDI Directeur Régional Paris (75) - Recrutement par Murano _ Hellowork.pdf",
            "id": "filesystem-v2:workflows/eBBXkB0vqJOsW6g8/executions/temp/binary_data/9f083239-56a3-418c-be94-f35ba4c690a2",
            "fileSize": "384 kB"
          }
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "connections": {
    "Webhook (Entrée Unique)": {
      "main": [
        [
          {
            "node": "Input Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router (Switch Action)": {
      "main": [
        [
          {
            "node": "Get Rate Limit Init",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Rate Limit Verify",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Hash Incoming Token",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Sécurité (Vérifier JWT)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Code OTP": {
      "main": [
        [
          {
            "node": "Sécu: Stocker Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vérifier Code (Mock)": {
      "main": [
        [
          {
            "node": "Supprimé Code Utilisé",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sécurité (Vérifier JWT)": {
      "main": [
        [
          {
            "node": "Log: Chat Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Whisper (STT)": {
      "main": [
        [
          {
            "node": "Context Merger",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Réponse Init": {
      "main": [
        [
          {
            "node": "Send email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sécu: Stocker Code": {
      "main": [
        [
          {
            "node": "Réponse Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get stored OTP code": {
      "main": [
        [
          {
            "node": "Vérifier Code (Mock)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get CRM Contact": {
      "main": [
        [
          {
            "node": "Update CRM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update CRM": {
      "main": [
        [
          {
            "node": "Générer Code OTP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "Whisper (STT)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [],
        []
      ]
    },
    "OpenAI Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Get All Groups": {
      "main": [
        [
          {
            "node": "Merge Groups Names",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Google Contacts": {
      "main": [
        [
          {
            "node": "Get All Groups",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Groups Names": {
      "main": [
        [
          {
            "node": "Log: Auth Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router (Content Type)": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Restore Binary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Context Merger",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Restore Binary": {
      "main": [
        [
          {
            "node": "File Gatekeeper",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supprimé Code Utilisé": {
      "main": [
        [
          {
            "node": "Check Google Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Access Token": {
      "main": [
        [
          {
            "node": "Générer Refresh Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Refresh Token": {
      "main": [
        [
          {
            "node": "Sauvegarder Refresh Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sauvegarder Refresh Token": {
      "main": [
        [
          {
            "node": "Réponse Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log: Auth Success": {
      "main": [
        [
          {
            "node": "Générer Access Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log: Auth Failed": {
      "main": [
        [
          {
            "node": "Erreur Auth",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log: Chat Message": {
      "main": [
        [
          {
            "node": "Router (Content Type)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normaliseur d'Erreur": {
      "main": [
        [
          {
            "node": "Log: Auth Failed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hash Incoming Token": {
      "main": [
        [
          {
            "node": "Get Refresh Token Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Refresh Token Info": {
      "main": [
        [
          {
            "node": "Validate & Rotate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Rotate": {
      "main": [
        [
          {
            "node": "Delete Old Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Token": {
      "main": [
        [
          {
            "node": "Générer Access Token 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Access Token 1": {
      "main": [
        [
          {
            "node": "Générer Refresh Token 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Refresh Token 1": {
      "main": [
        [
          {
            "node": "Sauvegarder Refresh Token 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sauvegarder Refresh Token 1": {
      "main": [
        [
          {
            "node": "Réponse Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Rate Limit Init": {
      "main": [
        [
          {
            "node": "Check Limit Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Limit Init": {
      "main": [
        [
          {
            "node": "Update Rate Limit Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Rate Limit Init": {
      "main": [
        [
          {
            "node": "Block or Pass",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Rate Limit Verify": {
      "main": [
        [
          {
            "node": "Check Limit Verify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Limit Verify": {
      "main": [
        [
          {
            "node": "Update Rate Limit Verify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Rate Limit Verify": {
      "main": [
        [
          {
            "node": "Block or Pass Verify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Block or Pass": {
      "main": [
        [
          {
            "node": "Throw Error",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get CRM Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Block or Pass Verify": {
      "main": [
        [
          {
            "node": "Throw Error Verify",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get stored OTP code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send email": {
      "main": [
        [],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Throw Error": {
      "main": [
        [],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Throw Error Verify": {
      "main": [
        [],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Input Validation": {
      "main": [
        [
          {
            "node": "Router (Switch Action)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "File Gatekeeper": {
      "main": [
        [
          {
            "node": "Context Merger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router Ollama": {
      "main": [
        []
      ]
    },
    "Router (Switch Intent)": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Workflow RAG",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Workflow RAG": {
      "main": [
        [
          {
            "node": "Is PDF?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Is PDF?": {
      "main": [
        [
          {
            "node": "Send email1",
            "type": "main",
            "index": 0
          }
        ],
        []
      ]
    },
    "Send email1": {
      "main": [
        [],
        []
      ]
    },
    "Call 'Philippe AI Brain (Central - Final Fix)'": {
      "main": [
        [
          {
            "node": "Réponse Chat",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Context Merger": {
      "main": [
        [
          {
            "node": "Rights Analyzer",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model1": {
      "ai_languageModel": [
        [
          {
            "node": "Guardrail - Topic Filter",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "Rights Analyzer": {
      "main": [
        [
          {
            "node": "Parse Rights",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Rights": {
      "main": [
        [
          {
            "node": "Router (User Rights)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router (User Rights)": {
      "main": [
        [
          {
            "node": "Call 'Philippe AI Brain (Central - Final Fix)'",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Shadow Brain Response",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Rejection Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "98f978c7-6c34-4747-8124-20128fb05da5",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "2194913e407b1e503ee1051e748fa0b50f28c847d89d91263b2430bdb12da207"
  },
  "id": "eBBXkB0vqJOsW6g8",
  "tags": [
    {
      "updatedAt": "2026-01-12T16:26:32.123Z",
      "createdAt": "2026-01-12T16:26:32.123Z",
      "id": "0xE9WHXJKvU4ffh4",
      "name": "Chatbot"
    }
  ]
}