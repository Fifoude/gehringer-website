{
  "name": "Backend Chat API",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "chat-api",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "710e42e7-f70f-4ea1-98f2-d9ca7c943158",
      "name": "Webhook (Entrée Unique)",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [
        -1792,
        2160
      ],
      "webhookId": "d41783e1-c8f6-4aba-bd51-5016acb5582a"
    },
    {
      "parameters": {
        "dataType": "string",
        "value1": "={{ $json.action }}",
        "rules": {
          "rules": [
            {
              "value2": "auth-init"
            },
            {
              "value2": "auth-verify",
              "output": 1
            },
            {
              "value2": "chat-message",
              "output": 3
            },
            {
              "value2": "refresh-token",
              "output": 2
            }
          ]
        }
      },
      "id": "3c113445-f66a-40c5-b558-7ceef57ece46",
      "name": "Router (Switch Action)",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 1,
      "position": [
        -1264,
        2112
      ]
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\n// 1. Générer un code à 4 chiffres (pour l'utilisateur)\nconst code = Math.floor(1000 + Math.random() * 9000).toString();\n\n// 2. Créer le hash du code (pour la base de données)\n// On utilise SHA-256 qui est robuste\nconst codeHash = crypto.createHash('sha256').update(code).digest('hex');\n\n// Récupération sécurisée de l'email\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst email = body ? body.email : 'no-email-found';\n\nreturn {\n  email: email,\n  generated_code: code,      // NON-HASHÉ : À envoyer par email\n  code_hash: codeHash,       // HASHÉ : À stocker en DB\n  created_at: new Date().toISOString()\n};"
      },
      "id": "d2dd0bd1-fcfd-444b-b9d2-5de4fae49ebc",
      "name": "Générer Code OTP",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        1744
      ]
    },
    {
      "parameters": {
        "mode": "runOnceForEachItem",
        "jsCode": "const crypto = require('crypto');\n\n// 1. Récupération des inputs\nconst webhook = $('Webhook (Entrée Unique)').first().json;\nconst email = webhook.body.email;\nconst receivedCode = String(webhook.body.code).trim(); // Le '1234' tapé par l'utilisateur\n\n// 2. Données stockées (HASHÉES)\nconst storedHash = $json.code; // Attention: la colonne s'appelle toujours 'code' mais contient le hash\nconst storedDate = $json.created_at;\nconst rowId = $json.id;\n\nif (!storedHash) {\n  throw new Error(\"Aucun OTP trouvé pour cet email.\");\n}\n\n// 3. Vérification de l'expiration (5 min)\nconst EXPIRATION_MS = 5 * 60 * 1000;\nconst now = new Date().getTime();\nconst createdAt = new Date(storedDate).getTime();\n\nif (now - createdAt > EXPIRATION_MS) {\n  throw new Error(\"Code OTP expiré. Veuillez en demander un nouveau.\");\n}\n\n// 4. HASHAGE ET COMPARAISON\n// On hashe le code reçu pour voir s'il correspond au hash stocké\nconst receivedCodeHash = crypto.createHash('sha256').update(receivedCode).digest('hex');\n\nif (receivedCodeHash !== storedHash) {\n  throw new Error(\"Code OTP invalide.\");\n}\n\n// 5. Succès\nreturn {\n  email,\n  valid: true,\n  rowIdToDelete: rowId\n};"
      },
      "id": "d83c6509-0517-4be9-8f05-5de6636107bc",
      "name": "Vérifier Code (Mock)",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        384,
        1952
      ],
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "operation": "verify",
        "token": "={{ $('Webhook (Entrée Unique)').item.json.headers.authorization.split(' ')[1] }}",
        "options": {}
      },
      "id": "7d475c4b-d0b7-4b31-821f-4c970955bf66",
      "name": "Sécurité (Vérifier JWT)",
      "type": "n8n-nodes-base.jwt",
      "typeVersion": 1,
      "position": [
        -912,
        2912
      ],
      "credentials": {
        "jwtAuth": {
          "id": "MSrsIWMcCZiwYCvf",
          "name": "JWT Auth account"
        }
      },
      "onError": "continueErrorOutput",
      "notes": "Valide le jeton d'accès fourni par le chatbot. Extrait l'email et les labels de l'utilisateur (permissions) contenus dans le payload."
    },
    {
      "parameters": {
        "resource": "audio",
        "operation": "transcribe",
        "binaryPropertyName": "audio",
        "options": {}
      },
      "id": "e858ed12-7ebb-4657-a1fc-5bf3cef32834",
      "name": "Whisper (STT)",
      "type": "@n8n/n8n-nodes-langchain.openAi",
      "typeVersion": 1,
      "position": [
        96,
        2688
      ],
      "credentials": {
        "openAiApi": {
          "id": "pe1RxUmCYaJzcwAP",
          "name": "OpenAi account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "options": {}
      },
      "id": "ae494def-7b16-4173-8590-b0de706f6427",
      "name": "Réponse Init",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1296,
        1744
      ]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ \n  (() => {\n    // On cherche d'abord si la branche Login a produit quelque chose\n    let data = null;\n    try {\n        const loginItem = $('Générer Refresh Token').last(); \n        if (loginItem && loginItem.json && loginItem.json.accessToken) {\n            data = loginItem.json;\n        }\n    } catch (e) {}\n\n    // Si rien, on cherche dans la branche Refresh\n    if (!data) {\n        try {\n            const refreshItem = $('Générer Refresh Token 1').last();\n            if (refreshItem && refreshItem.json && refreshItem.json.accessToken) {\n                data = refreshItem.json;\n            }\n        } catch (e) {}\n    }\n\n    // Retourne le JSON stringifié (impératif pour ce champ)\n    if (data) {\n        return JSON.stringify({\n            accessToken: data.accessToken,\n            refreshToken: data.refreshToken\n        });\n    }\n    return JSON.stringify({ error: \"Tokens introuvables\" });\n  })()\n}}",
        "options": {}
      },
      "id": "c59cdbb2-4cf0-4ce7-83b1-b2e5233c7a3f",
      "name": "Réponse Token",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [
        1504,
        2160
      ]
    },
    {
      "parameters": {
        "fromEmail": "contact@gehringer.fr",
        "toEmail": "={{ $json.email }}",
        "subject": "Your code",
        "html": "=Bonjour,\n\nvoici le code pour chatter: {{ $('Générer Code OTP').item.json.generated_code }}\n\nEn continuant, vous acceptez que votre email soit utilisé pour traiter votre demande.\n\nMerci !",
        "options": {
          "appendAttribution": false,
          "bccEmail": "philippe.lakas@gmail.com",
          "replyTo": "web.contact@gehringer.fr"
        }
      },
      "type": "n8n-nodes-base.emailSend",
      "typeVersion": 2.1,
      "position": [
        1488,
        1744
      ],
      "id": "c3fcd231-82de-4d11-8cec-806839dec3bf",
      "name": "Send email",
      "webhookId": "25e76513-a504-43d5-9a46-87dc60e1b24a",
      "credentials": {
        "smtp": {
          "id": "IpKC6W2ftYil9cca",
          "name": "SMTP account"
        }
      },
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "IWWDAHh3QCefwYYN",
          "mode": "list",
          "cachedResultName": "OTP_Codes",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/IWWDAHh3QCefwYYN"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "code": "={{ $json.code_hash }}",
            "email": "={{ $json.email }}",
            "created_at": "={{ $json.created_at }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "code",
              "displayName": "code",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "created_at",
              "displayName": "created_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        896,
        1744
      ],
      "id": "d4f5442a-15f5-4c05-a1f3-314be6022883",
      "name": "Sécu: Stocker Code"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "IWWDAHh3QCefwYYN",
          "mode": "list",
          "cachedResultName": "OTP_Codes",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/IWWDAHh3QCefwYYN"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        208,
        1952
      ],
      "id": "48c6b1c4-6c65-4043-b4f5-498b72ba935f",
      "name": "Get stored OTP code"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "yfw8czdVcKrGjiy1",
          "mode": "list",
          "cachedResultName": "CRM_Contacts",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/yfw8czdVcKrGjiy1"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        368,
        1744
      ],
      "id": "73d98f89-7ec7-4b66-a655-c823a20e54a1",
      "name": "Get CRM Contact",
      "alwaysOutputData": true,
      "notes": "Est-ce que l'email existe ?"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "yfw8czdVcKrGjiy1",
          "mode": "list",
          "cachedResultName": "CRM_Contacts",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/yfw8czdVcKrGjiy1"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $('Webhook (Entrée Unique)').item.json.body.email }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "interaction_count": "={{ (Number($('Get CRM Contact').first().json.interaction_count) || 0) + 1 }}",
            "last_seen": "={{ new Date().toISOString() }}",
            "email": "={{ $('Webhook (Entrée Unique)').item.json.body.email }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "interaction_count",
              "displayName": "interaction_count",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "last_seen",
              "displayName": "last_seen",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        544,
        1744
      ],
      "id": "15f6a4db-6446-448b-a8b1-8ee6437777d1",
      "name": "Update CRM",
      "notes": "Màj de CRM"
    },
    {
      "parameters": {
        "jsCode": "// Récupération chirurgicale du binaire depuis le Webhook initial\nconst binaryData = $('Webhook (Entrée Unique)').first().binary;\n\nreturn [{\n  json: items[0].json, // On garde le JSON courant (token, etc.)\n  binary: binaryData   // On réinjecte le binaire manquant\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -224,
        2704
      ],
      "id": "3d462e9f-61f5-4eea-a8c5-cceb22304700",
      "name": "Code in JavaScript1"
    },
    {
      "parameters": {
        "url": "https://people.googleapis.com/v1/contactGroups",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleContactsOAuth2Api",
        "options": {}
      },
      "id": "ad439dc2-b6c1-4622-905b-7aac76ae9ca1",
      "name": "Get All Groups",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        624,
        2144
      ],
      "credentials": {
        "googleContactsOAuth2Api": {
          "id": "xyMVAK068yLHLVtF",
          "name": "Google Contacts account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "url": "https://people.googleapis.com/v1/people:searchContacts",
        "authentication": "predefinedCredentialType",
        "nodeCredentialType": "googleContactsOAuth2Api",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "query",
              "value": "={{ $json.email }}"
            },
            {
              "name": "readMask",
              "value": "names,emailAddresses,memberships"
            }
          ]
        },
        "options": {}
      },
      "id": "ce9b3512-b843-4995-abde-40d943964a2b",
      "name": "Check Google Contacts",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.1,
      "position": [
        448,
        2144
      ],
      "alwaysOutputData": true,
      "retryOnFail": true,
      "credentials": {
        "googleContactsOAuth2Api": {
          "id": "xyMVAK068yLHLVtF",
          "name": "Google Contacts account"
        }
      },
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "jsCode": "const response = $('Check Google Contacts').first().json;\n// The API returns { results: [ { person: { ... } } ] }\n// If no results, 'results' is undefined or empty\nconst person = (response.results && response.results.length > 0) ? response.results[0].person : {};\n\nconst groups = $('Get All Groups').first().json.contactGroups || [];\n\n// Create Map: resourceName -> formattedName\nconst groupMap = {};\ngroups.forEach(g => {\n  groupMap[g.resourceName] = g.formattedName;\n});\n\n// Extract User Memberships (safe access)\nconst rawMemberships = person.memberships || [];\n\nconst labels = rawMemberships.map(m => {\n   const resName = m.contactGroupMembership ? m.contactGroupMembership.contactGroupResourceName : null;\n   return groupMap[resName] || resName;\n}).filter(l => l != null);\n\n// Fallback email if contact not found\n// Note: original email input is needed if person.emailAddresses is empty\nconst verifiedEmail = $('Vérifier Code (Mock)').first().json.email;\nconst googleEmail = (person.emailAddresses && person.emailAddresses.length > 0) ? person.emailAddresses[0].value : null;\n\nreturn {\n  email: googleEmail || verifiedEmail,\n  user_labels: labels\n};"
      },
      "id": "93a0e6de-5cb0-42e1-8708-4f7ff149fed3",
      "name": "Merge Groups Names",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        800,
        2144
      ],
      "onError": "continueRegularOutput"
    },
    {
      "parameters": {
        "rules": {
          "values": [
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "leftValue": "={{ $('Webhook (Entrée Unique)').first().binary?.audio != null || ($('Webhook (Entrée Unique)').first().binary?.data?.mimeType?.startsWith('audio/') || false) }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    },
                    "id": "385fec2f-02e9-442e-adbd-e95283016e70"
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "audio"
            },
            {
              "conditions": {
                "options": {
                  "caseSensitive": true,
                  "leftValue": "",
                  "typeValidation": "strict",
                  "version": 1
                },
                "conditions": [
                  {
                    "id": "000cf1d9-012c-456f-94e7-cc7ba22e7c01",
                    "leftValue": "={{ $('Webhook (Entrée Unique)').first().binary?.file != null || $('Webhook (Entrée Unique)').first().binary?.data != null }}",
                    "rightValue": "",
                    "operator": {
                      "type": "boolean",
                      "operation": "true",
                      "singleValue": true
                    }
                  }
                ],
                "combinator": "and"
              },
              "renameOutput": true,
              "outputKey": "doc"
            }
          ]
        },
        "options": {
          "fallbackOutput": "extra"
        }
      },
      "id": "664d1045-828f-4803-81b6-eb8cb13e47af",
      "name": "Router (Content Type)",
      "type": "n8n-nodes-base.switch",
      "typeVersion": 3,
      "position": [
        -448,
        2896
      ],
      "notesInFlow": false,
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "operation": "deleteRows",
        "dataTableId": {
          "__rl": true,
          "value": "IWWDAHh3QCefwYYN",
          "mode": "list",
          "cachedResultName": "OTP_Codes",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/IWWDAHh3QCefwYYN"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyValue": "={{ $json.rowIdToDelete }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        544,
        1952
      ],
      "id": "8e17d6e4-693a-4b75-baa0-612f887ea17f",
      "name": "Supprimé Code Utilisé"
    },
    {
      "parameters": {
        "useJson": true,
        "claimsJson": "={\n  \"expiresIn\": 900,\n  \"email\": \"{{ $('Vérifier Code (Mock)').first().json.email }}\",\n  \"user_labels\": \"{{ $('Merge Groups Names').item.json.user_labels }}\"\n}",
        "options": {}
      },
      "id": "051bc2eb-af4e-4a66-a3b2-d72979f1f5d1",
      "name": "Générer Access Token",
      "type": "n8n-nodes-base.jwt",
      "typeVersion": 1,
      "position": [
        896,
        1952
      ],
      "notesInFlow": true,
      "credentials": {
        "jwtAuth": {
          "id": "MSrsIWMcCZiwYCvf",
          "name": "JWT Auth account"
        }
      },
      "notes": "Token sert aux requêtes immédiates du chat"
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\n// 1. Récupérer l'Access Token généré juste avant (il est dans la propriété \"token\" ou la clé principale selon votre version)\n// Note: Le noeud JWT met souvent le résultat dans une propriété. Vérifiez l'input.\nconst accessToken = $json.token || $json; \nconst email = $('Vérifier Code (Mock)').first().json.email;\n\n// 2. Générer le Refresh Token (Opaque String)\nconst refreshToken = crypto.randomBytes(40).toString('hex');\n\n// 3. Calculer le Hash pour la base de données (SHA-256)\nconst tokenHash = crypto.createHash('sha256').update(refreshToken).digest('hex');\n\n// 4. Calculer la date d'expiration (+7 jours)\nconst expiry = new Date();\nexpiry.setDate(expiry.getDate() + 7);\n\nreturn {\n  email: email,\n  accessToken: accessToken,      // Le JWT court\n  refreshToken: refreshToken,    // Le secret à envoyer à l'utilisateur\n  tokenHash: tokenHash,          // Le hash à stocker\n  expiresAt: expiry.toISOString()\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1088,
        1952
      ],
      "id": "02183793-9bba-4c30-aca8-232dc4872610",
      "name": "Générer Refresh Token"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "revoked": false,
            "email": "={{ $json.email }}",
            "token_hash": "={{ $json.tokenHash }}",
            "expires_at": "={{ $json.expiresAt }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "token_hash",
              "displayName": "token_hash",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "expires_at",
              "displayName": "expires_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "revoked",
              "displayName": "revoked",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {
          "optimizeBulk": false
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1296,
        1952
      ],
      "id": "efc3a8f4-7246-4215-bab7-d3cb47c63cca",
      "name": "Sauvegarder Refresh Token"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "ytaFSb3YU5YIFY0q",
          "mode": "list",
          "cachedResultName": "Audit_Logs",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/ytaFSb3YU5YIFY0q"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{ new Date().toISOString() }}",
            "email": "={{ $json.email }}",
            "action": "=auth-verify",
            "status": "=success",
            "ip_address": "={{ $('Webhook (Entrée Unique)').first().json.headers['cf-connecting-ip'] || $('Webhook (Entrée Unique)').first().json.headers['x-forwarded-for'] }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "details",
              "displayName": "details",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": true
            },
            {
              "id": "ip_address",
              "displayName": "ip_address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        720,
        1952
      ],
      "id": "889d56f2-02ed-4675-85bf-aa8fdb34f8a2",
      "name": "Log: Auth Success"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"error\": \"{{ $json.details.replace(/ \\[line \\d+\\]/, '') }}\"\n}",
        "options": {
          "responseCode": 400
        }
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        1488,
        2400
      ],
      "id": "643319d7-c7bc-44d1-b86f-564e13be7bf7",
      "name": "Erreur Auth"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "ytaFSb3YU5YIFY0q",
          "mode": "list",
          "cachedResultName": "Audit_Logs",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/ytaFSb3YU5YIFY0q"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{ new Date().toISOString() }}",
            "email": "={{ $('Webhook (Entrée Unique)').first().json.body.email }}",
            "action": "=auth-verify-fail",
            "status": "=error",
            "ip_address": "={{ $('Webhook (Entrée Unique)').first().json.headers['cf-connecting-ip'] }}",
            "details": "={{ $json.error }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "details",
              "displayName": "details",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "ip_address",
              "displayName": "ip_address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        1296,
        2400
      ],
      "id": "2829c145-a35d-424d-9f60-08232fdcffaa",
      "name": "Log: Auth Failed"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "ytaFSb3YU5YIFY0q",
          "mode": "list",
          "cachedResultName": "Audit_Logs",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/ytaFSb3YU5YIFY0q"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "timestamp": "={{ new Date().toISOString() }}",
            "email": "={{ $json.payload.email }}",
            "action": "=chat-message",
            "status": "=success",
            "ip_address": "={{ $('Webhook (Entrée Unique)').first().json.headers['cf-connecting-ip'] }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "timestamp",
              "displayName": "timestamp",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "status",
              "displayName": "status",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "details",
              "displayName": "details",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": true
            },
            {
              "id": "ip_address",
              "displayName": "ip_address",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -688,
        2912
      ],
      "id": "a56b8f98-2427-46c3-8694-dd12cbb591e7",
      "name": "Log: Chat Message",
      "notes": "Enregistre la tentative de message dans la table Audit_Logs. Indispensable pour la traçabilité et le monitoring des usages par email et IP."
    },
    {
      "parameters": {
        "jsCode": "// Harmonise l'erreur quelle que soit sa source\nconst errorItem = $input.item.json;\nlet msg = errorItem.message || errorItem.error || \"Erreur inconnue\";\n\n// Nettoyage cosmétique\nmsg = msg.replace(/ \\[line \\d+\\]/, ''); \n\n// Détection du code HTTP suggéré\nlet status = 400;\nif (msg.includes('jwt expired') || msg.includes('token')) status = 401;\nif (msg.includes('connection') || msg.includes('timeout')) status = 503;\n\nreturn {\n  error: msg,  // Message propre pour l'utilisateur\n  raw_error: JSON.stringify(errorItem), // Pour les logs\n  http_status: status // Pour le nœud Response\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        1104,
        2400
      ],
      "id": "b1cd7194-fc12-4574-85d1-7e81ed1c2f64",
      "name": "Normaliseur d'Erreur"
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n// On s'assure d'avoir le token, qu'il vienne du body ou d'ailleurs\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst refreshToken = body.refreshToken;\n\nif (!refreshToken) {\n  throw new Error(\"Refresh Token manquant dans la requête.\");\n}\n\n// Hashage\nconst hash = crypto.createHash('sha256').update(refreshToken).digest('hex');\n\nreturn { \n  token_hash_to_find: hash,\n  original_token: refreshToken\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -736,
        2384
      ],
      "id": "38b48e24-e671-4151-8f35-bf3d8243fc09",
      "name": "Hash Incoming Token"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "token_hash",
              "keyValue": "={{ $json.token_hash_to_find }}"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -576,
        2384
      ],
      "id": "170a1edb-fae3-40b6-a1b3-109ea5e3cb2b",
      "name": "Get Refresh Token Info",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const storedToken = $input.item.json;\n\n// 1. Vérifications\nif (!storedToken || !storedToken.id) { // Si pas d'ID, c'est que rien n'a été trouvé\n   throw new Error(\"Refresh token introuvable ou invalide.\");\n}\n\nif (storedToken.revoked) {\n   throw new Error(\"Ce token a été révoqué.\");\n}\n\nconst expiresAt = new Date(storedToken.expires_at).getTime();\nif (Date.now() > expiresAt) {\n   throw new Error(\"Refresh token expiré (Session terminée).\");\n}\n\n// 2. Préparer la suite (On renvoie l'email pour le futur JWT)\nreturn {\n   email: storedToken.email,\n   oldTokenId: storedToken.id // ID à supprimer pour la rotation\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -400,
        2384
      ],
      "id": "87601acc-f5c5-438e-bc4a-ac831dc85d8d",
      "name": "Validate & Rotate"
    },
    {
      "parameters": {
        "operation": "deleteRows",
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "filters": {
          "conditions": [
            {
              "keyValue": "={{ $json.oldTokenId }}"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -224,
        2384
      ],
      "id": "60c8b2ec-a8ec-496f-b721-79c343ad63f8",
      "name": "Delete Old Token"
    },
    {
      "parameters": {
        "useJson": true,
        "claimsJson": "={\n  \"expiresIn\": 900,\n  \"email\": \"{{ $json.email }}\",\n  \"user_labels\": \"{{ $json.user_labels || [] }}\"\n}",
        "options": {}
      },
      "id": "a1457906-faf3-4719-8eee-b01966fe6331",
      "name": "Générer Access Token 1",
      "type": "n8n-nodes-base.jwt",
      "typeVersion": 1,
      "position": [
        -16,
        2384
      ],
      "notesInFlow": true,
      "credentials": {
        "jwtAuth": {
          "id": "MSrsIWMcCZiwYCvf",
          "name": "JWT Auth account"
        }
      },
      "notes": "Token sert aux requêtes immédiates du chat"
    },
    {
      "parameters": {
        "jsCode": "const crypto = require('crypto');\n\n// 1. Récupérer l'Access Token généré juste avant (il est dans la propriété \"token\" ou la clé principale selon votre version)\n// Note: Le noeud JWT met souvent le résultat dans une propriété. Vérifiez l'input.\nconst accessToken = $json.token || $json; \nconst email = $('Vérifier Code (Mock)').first().json.email;\n\n// 2. Générer le Refresh Token (Opaque String)\nconst refreshToken = crypto.randomBytes(40).toString('hex');\n\n// 3. Calculer le Hash pour la base de données (SHA-256)\nconst tokenHash = crypto.createHash('sha256').update(refreshToken).digest('hex');\n\n// 4. Calculer la date d'expiration (+7 jours)\nconst expiry = new Date();\nexpiry.setDate(expiry.getDate() + 7);\n\nreturn {\n  email: email,\n  accessToken: accessToken,      // Le JWT court\n  refreshToken: refreshToken,    // Le secret à envoyer à l'utilisateur\n  tokenHash: tokenHash,          // Le hash à stocker\n  expiresAt: expiry.toISOString()\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        176,
        2384
      ],
      "id": "a7773c13-0082-43ae-b010-914d264d6ee4",
      "name": "Générer Refresh Token 1"
    },
    {
      "parameters": {
        "dataTableId": {
          "__rl": true,
          "value": "2OT5oshzteIuy55m",
          "mode": "list",
          "cachedResultName": "Active_Tokens",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/2OT5oshzteIuy55m"
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "revoked": false,
            "email": "={{ $json.email }}",
            "token_hash": "={{ $json.tokenHash }}",
            "expires_at": "={{ $json.expiresAt }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "token_hash",
              "displayName": "token_hash",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "expires_at",
              "displayName": "expires_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "revoked",
              "displayName": "revoked",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "boolean",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        384,
        2384
      ],
      "id": "462ded48-21db-4ecf-94cf-313e81389791",
      "name": "Sauvegarder Refresh Token 1"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "=auth-init"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -784,
        1744
      ],
      "id": "a426e8f9-eab4-42b7-953d-10db767bf67b",
      "name": "Get Rate Limit Init",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const limit = $input.item.json; // Résultat de la DB\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst email = body.email;\nconst now = new Date();\n\n// Configuration\nconst MAX_ATTEMPTS = 3;\nconst WINDOW_MINUTES = 15;\nconst BLOCK_MINUTES = 30;\n\nlet newCount = 1;\nlet firstDates = now.toISOString();\nlet blockedUntil = null;\nlet errorMessage = null; // Variable pour stocker l'erreur potentielle\n\n// Vérifier si déjà un enregistrement\nif (limit.id) {\n  // 1. Est-il DÉJÀ bloqué ?\n  if (limit.blocked_until && new Date(limit.blocked_until) > now) {\n     const minutesLeft = Math.ceil((new Date(limit.blocked_until) - now) / 60000);\n     errorMessage = `Trop de tentatives. Réessayez dans ${minutesLeft} minutes.`;\n     // On garde les anciennes valeurs pour ne pas les écraser\n     newCount = limit.count;\n     firstDates = limit.first_attempt_at;\n     blockedUntil = limit.blocked_until;\n     \n  } else {\n      // 2. Vérification de la fenêtre de temps\n      const firstAttempt = new Date(limit.first_attempt_at);\n      const diffMinutes = (now - firstAttempt) / 60000;\n\n      if (diffMinutes > WINDOW_MINUTES) {\n         // Fenêtre expirée, on reset tout\n         newCount = 1;\n         firstDates = now.toISOString();\n         blockedUntil = null;\n      } else {\n         // Dans la fenêtre, on incrémente\n         newCount = (limit.count || 0) + 1;\n         firstDates = limit.first_attempt_at;\n         \n         if (newCount > MAX_ATTEMPTS) {\n            // On bloque MAINTENANT\n            const blockDate = new Date(now.getTime() + BLOCK_MINUTES * 60000);\n            blockedUntil = blockDate.toISOString();\n            errorMessage = \"Trop de demandes de code. Compte bloqué 30 min.\";\n         }\n      }\n  }\n}\n\nreturn {\n   email: email,\n   action: 'auth-init', // Rappel : Mettre 'auth-verify' pour l'autre branche\n   count: newCount,\n   first_attempt_at: firstDates,\n   blocked_until: blockedUntil,\n   error_to_throw: errorMessage // LA clé magique\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        1744
      ],
      "id": "f1e083c3-60f2-4242-b9e8-5f0fd887e0f0",
      "name": "Check Limit Init"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "={{ $json.action }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "count": "={{ $json.count }}",
            "email": "={{ $json.email }}",
            "action": "={{ $json.action }}",
            "first_attempt_at": "={{ $json.first_attempt_at }}",
            "blocked_until": "={{ $json.blocked_until }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "count",
              "displayName": "count",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "first_attempt_at",
              "displayName": "first_attempt_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "blocked_until",
              "displayName": "blocked_until",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -432,
        1744
      ],
      "id": "0a7445b2-f771-42c5-83e1-d42cf9529d74",
      "name": "Update Rate Limit Init"
    },
    {
      "parameters": {
        "operation": "get",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "=auth-verify"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -784,
        1968
      ],
      "id": "9ff3211a-6c46-4cbe-a210-3edaaf84ac72",
      "name": "Get Rate Limit Verify",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "const limit = $input.item.json; // Résultat de la DB\nconst body = $('Webhook (Entrée Unique)').first().json.body;\nconst email = body.email;\nconst now = new Date();\n\n// Configuration SPECIFIQUE 'Verify'\nconst MAX_ATTEMPTS = 5;      // 5 essais\nconst WINDOW_MINUTES = 5;    // En 5 minutes\nconst BLOCK_MINUTES = 30;    // Blocage 30 min\n\nlet newCount = 1;\nlet firstDates = now.toISOString();\nlet blockedUntil = null;\nlet errorMessage = null;\n\n// Vérifier si déjà un enregistrement\nif (limit.id) {\n  // 1. Est-il DÉJÀ bloqué ?\n  if (limit.blocked_until && new Date(limit.blocked_until) > now) {\n     const minutesLeft = Math.ceil((new Date(limit.blocked_until) - now) / 60000);\n     errorMessage = `Compte bloqué. Réessayez dans ${minutesLeft} minutes.`;\n     newCount = limit.count;\n     firstDates = limit.first_attempt_at;\n     blockedUntil = limit.blocked_until;\n     \n  } else {\n      // 2. Vérification de la fenêtre de temps\n      const firstAttempt = new Date(limit.first_attempt_at);\n      const diffMinutes = (now - firstAttempt) / 60000;\n\n      if (diffMinutes > WINDOW_MINUTES) {\n         // Fenêtre expirée, on reset\n         newCount = 1;\n         firstDates = now.toISOString();\n         blockedUntil = null;\n      } else {\n         // Dans la fenêtre, on incrémente\n         newCount = (limit.count || 0) + 1;\n         firstDates = limit.first_attempt_at;\n         \n         if (newCount > MAX_ATTEMPTS) {\n            // On bloque MAINTENANT\n            const blockDate = new Date(now.getTime() + BLOCK_MINUTES * 60000);\n            blockedUntil = blockDate.toISOString();\n            errorMessage = \"Trop d'essais incorrects. Compte bloqué 30 min.\";\n         }\n      }\n  }\n}\n\nreturn {\n   email: email,\n   action: 'auth-verify', // Important : c'est l'action 'verify' ici\n   count: newCount,\n   first_attempt_at: firstDates,\n   blocked_until: blockedUntil,\n   error_to_throw: errorMessage\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -608,
        1968
      ],
      "id": "721fc756-a035-4ccf-ba76-c234678c23b5",
      "name": "Check Limit Verify"
    },
    {
      "parameters": {
        "operation": "upsert",
        "dataTableId": {
          "__rl": true,
          "value": "Wj31NRNRUZU5hf1r",
          "mode": "list",
          "cachedResultName": "Rate_Limits",
          "cachedResultUrl": "/projects/HmXlcweiu5I7NsBE/datatables/Wj31NRNRUZU5hf1r"
        },
        "matchType": "allConditions",
        "filters": {
          "conditions": [
            {
              "keyName": "email",
              "keyValue": "={{ $json.email }}"
            },
            {
              "keyName": "action",
              "keyValue": "={{ $json.action }}"
            }
          ]
        },
        "columns": {
          "mappingMode": "defineBelow",
          "value": {
            "count": "={{ $json.count }}",
            "email": "={{ $json.email }}",
            "action": "={{ $json.action }}",
            "first_attempt_at": "={{ $json.first_attempt_at }}",
            "blocked_until": "={{ $json.blocked_until }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "action",
              "displayName": "action",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "string",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "count",
              "displayName": "count",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "number",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "first_attempt_at",
              "displayName": "first_attempt_at",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            },
            {
              "id": "blocked_until",
              "displayName": "blocked_until",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "type": "dateTime",
              "readOnly": false,
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        },
        "options": {}
      },
      "type": "n8n-nodes-base.dataTable",
      "typeVersion": 1,
      "position": [
        -432,
        1968
      ],
      "id": "f5fd860d-89c1-4679-8b95-f20cce424608",
      "name": "Update Rate Limit Verify"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "02fd86a9-959e-4873-9517-4fa10b9b33e0",
              "leftValue": "={{ $('Check Limit Init').first().json.error_to_throw }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -224,
        1744
      ],
      "id": "fca3f792-e1c1-49a9-b5d0-b27044ee8da5",
      "name": "Block or Pass"
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "version": 3,
            "leftValue": "",
            "caseSensitive": true,
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "10a2a8e3-7539-46f0-89fd-e1f9b1673715",
              "leftValue": "={{ $('Check Limit Verify').first().json.error_to_throw }}",
              "rightValue": "",
              "operator": {
                "type": "string",
                "operation": "notEmpty"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 2.3,
      "position": [
        -224,
        1968
      ],
      "id": "1bdfdd6d-ea0a-4cb5-b00a-b8b1ff86a4d5",
      "name": "Block or Pass Verify"
    },
    {
      "parameters": {
        "content": "## Gestion des erreurs (à peaufiner)\n(Si votre variable s'appelle $json.error ou $json.message, adaptez juste le début. Le .replace(...) est standard).\n\n2. Centraliser la gestion des erreurs (Branche \"Catch-All\")\nAbsolument ! C'est même une \"best practice\" en architecture n8n appelée le pattern Error Workflow ou Error Trigger.\n\nMais sans créer un workflow séparé complexe, vous pouvez tout à fait connecter plusieurs nœuds à votre branche d'erreur existante.\n\nComment ça marche ? Pour chaque nœud critique, vous allez dans ses Settings -> On Error -> Continue (using error output). Cela fait apparaître la 2ème sortie (grise/rouge). Vous tirez ensuite un fil de cette sortie vers l'entrée de votre branche \"Erreur\" (le nœud Log: Auth Failed ou directement Erreur Auth).\n\nListe des nœuds à connecter (suggérés) :\n\nSécurité (Vérifier JWT) : ESSENTIEL.\nSi le token est expiré ou invalide, cela plante le workflow. En le connectant à Erreur Auth, l'utilisateur recevra un propre 401/400 et le Frontend pourra (comme on l'a codé hier) lui dire \"Session expirée\".\nNote : Modifiez le message d'erreur dans Erreur Auth pour gérer le cas spécifique (ex: si le message contient \"jwt expired\", renvoyer un code HTTP 401).\nCheck Google Contacts (HTTP Request) :\nSi l'API Google est en panne ou rejette la requête (quota, erreur 500), le workflow s'arrête.\nConnectez-le pour dire \"Service temporairement indisponible\".\nWhisper (STT) & OpenAI Chat Model :\nSi OpenAI est down ou timeout, c'est critique de prévenir l'utilisateur (\"L'IA ne répond pas pour le moment\").\nSend Email :\nSi le SMTP échoue, l'utilisateur attend son code pour rien. Il vaut mieux lui dire \"Impossible d'envoyer l'email, réessayez\".\nAttention à la structure du JSON d'erreur ! Quand un nœud plante, il sort un JSON qui ressemble souvent à :\n\njson\n{\n  \"message\": \"Error description\",\n  \"name\": \"NodeApiError\",\n  ...\n}\nVotre nœud Log: Auth Failed attend actuellement un champ bien précis pour le details. L'astuce est d'insérer un petit nœud Code (ou \"Edit Fields\") juste au début de votre branche erreur commune qui normalise tout ça :\n\nArchitecture Recommandée :\n\nmermaid\ngraph TD\n    A[Vérifier Code] -- Error --> X[Normaliseur d'Erreur]\n    B[Vérifier JWT] -- Error --> X\n    C[OpenAI] -- Error --> X\n    \n    X -- Standardized Error --> Y[Log: Auth/Global Failed]\n    Y --> Z[Erreur Auth (Response 400/500)]",
        "height": 1136,
        "width": 608
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -1792,
        2416
      ],
      "typeVersion": 1,
      "id": "513fe628-7f05-4b6e-b931-934c54278081",
      "name": "Sticky Note"
    },
    {
      "parameters": {
        "jsCode": "throw new Error($('Check Limit Init').first().json.error_to_throw);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        0,
        1728
      ],
      "id": "20d637c7-a1d7-486e-b560-efe789636d51",
      "name": "Throw Error",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "throw new Error($('Check Limit Verify').first().json.error_to_throw);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -16,
        1952
      ],
      "id": "bffdc9ee-460a-41ed-b7ce-2a518fd41e3c",
      "name": "Throw Error Verify",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "/* \n   🛡️ SECURITY GATEKEEPER \n   Ce nœud valide toutes les entrées avant qu'elles ne touchent la logique métier.\n*/\n\nconst body = $input.item.json.body || {};\nconst action = body.action;\nconst email = body.email;\n\n// 1. Validation de l'Action (Whitelist)\nconst ALLOWED_ACTIONS = ['auth-init', 'auth-verify', 'chat-message', 'refresh-token'];\nif (!ALLOWED_ACTIONS.includes(action)) {\n   throw new Error(`Action non autorisée ou inconnue: ${action}`);\n}\n\n// 2. Validation de l'Email (Seulement pour l'auth initiale/verif)\nif (['auth-init', 'auth-verify'].includes(action)) { // <--- CHANGEMENT ICI\n    const emailRegex = /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,6}$/;\n    if (!email || !emailRegex.test(email)) {\n       throw new Error(\"Format d'email invalide.\");\n    }\n}\n\n// 3. Validation OTP (Si verify)\nif (action === 'auth-verify') {\n    const code = body.code;\n    if (!code || !/^\\d{4}$/.test(code)) { // Doit être 4 chiffres exactement\n       throw new Error(\"Le code OTP doit être composé de 4 chiffres.\");\n    }\n}\n\n// 4. Validation Refresh Token\nif (action === 'refresh-token') {\n    if (!body.refreshToken || typeof body.refreshToken !== 'string' || body.refreshToken.length < 10) {\n        throw new Error(\"Refresh Token invalide.\");\n    }\n}\n\n// 5. Nettoyage basique (Sanitization)\n// On renvoie les données propres\nreturn {\n    ...body,\n    email: email ? email.toLowerCase().trim() : null, // Normalisation\n    _validated: true // Petit flag pour dire \"c'est validé\"\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -1552,
        2160
      ],
      "id": "10d319ee-5bc3-47fc-ae3f-a9b9264ee229",
      "name": "Input Validation",
      "onError": "continueErrorOutput"
    },
    {
      "parameters": {
        "jsCode": "// Récupération du binaire depuis le Webhook initial\nconst webhookBinary = $('Webhook (Entrée Unique)').first().binary;\n\n// On vérifie s'il y a du binaire (peu importe la clé : file, data, attachment...)\nconst keys = Object.keys(webhookBinary || {});\nif (keys.length === 0) {\n  throw new Error(\"Erreur interne : Le fichier a été perdu en cours de route.\");\n}\n\n// On standardise la clé à 'data' pour le Subworkflow (Extract Text attend 'data' par défaut)\nconst binaryData = webhookBinary[keys[0]];\n\nreturn [{\n  json: items[0].json,\n  binary: {\n    data: binaryData\n  }\n}];"
      },
      "id": "02190c20-1948-4943-b04b-9c5d2c38f572",
      "name": "Restore Binary",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        -208,
        3104
      ]
    },
    {
      "parameters": {
        "workflowId": {
          "__rl": true,
          "value": "wc1gPl32rku4ikBN",
          "mode": "list",
          "cachedResultUrl": "/workflow/wc1gPl32rku4ikBN",
          "cachedResultName": "Subworkflow - File Gatekeeper"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": true
        },
        "options": {}
      },
      "id": "52a6c3d3-069f-48a1-ab60-7f25f59564d6",
      "name": "File Gatekeeper",
      "type": "n8n-nodes-base.executeWorkflow",
      "typeVersion": 1.3,
      "position": [
        96,
        3120
      ]
    },
    {
      "parameters": {
        "jsCode": "/**\n * CONTEXT MERGER - VERSION NETTOYÉE avec i18n\n * \n * CHANGEMENTS PAR RAPPORT À LA VERSION PRÉCÉDENTE :\n * 1. ✅ Ajout de la récupération du paramètre 'lang'\n * 2. ✅ Suppression de 'sessionId' (inutile, géré par Memory node)\n * 3. ✅ Code nettoyé et commenté\n * \n * USAGE : Remplacer le code du nœud \"Context Merger\" existant par ce code\n */\n\nconst data = $input.first().json;\nlet webhookBody = {};\ntry {\n    webhookBody = $('Webhook (Entrée Unique)').first().json.body || {};\n} catch (e) {\n    console.log('Warning: Could not access webhook body');\n}\n\n// ========================================\n// 1. EXTRACTION DE L'EMAIL ET DES LABELS (depuis le JWT)\n// ========================================\nlet email = \"no-email\";\nlet userLabels = [];\n\ntry {\n    const jwtPayload = $('Sécurité (Vérifier JWT)').first().json.payload;\n    email = jwtPayload.email || \"no-email\";\n\n    if (jwtPayload.user_labels) {\n        userLabels = Array.isArray(jwtPayload.user_labels)\n            ? jwtPayload.user_labels\n            : jwtPayload.user_labels.split(',');\n    }\n} catch (e) {\n    console.log('Warning: Could not extract JWT payload');\n}\n\n// ========================================\n// 2. RÉCUPÉRATION DE LA LANGUE (i18n)\n// ========================================\nconst lang = webhookBody.lang || 'fr'; // Défaut : français\n\n// ========================================\n// 3. DISTINCTION DES ENTRÉES\n// ========================================\n// Texte saisi par l'utilisateur (inline dans le chat)\nconst user_text = webhookBody.text || webhookBody.chatInput || webhookBody.message || \"\";\n\n// Contenu extrait des médias (Audio STT ou PDF OCR)\nconst file_text = data.transcription || data.text || \"\";\n\n// ========================================\n// 4. CONSTRUCTION DU CHAMP 'chatInput' FINAL\n// ========================================\n// On combine proprement si les deux existent\nlet combinedQuery = user_text;\n\nif (file_text && file_text !== user_text) {\n    combinedQuery = user_text\n        ? `${user_text}\\n\\n[Contenu du document/audio]:\\n${file_text}`\n        : file_text;\n}\n\n// ========================================\n// 5. OUTPUT FINAL\n// ========================================\nreturn [{\n    json: {\n        // Identité utilisateur\n        email: email,\n        user_labels: userLabels,\n\n        // Langue (i18n)\n        lang: lang,\n\n        // Contenus séparés (pour audit et logging)\n        text_input: user_text,           // Ce que l'user a tapé\n        media_transcription: file_text,  // Ce qui vient de l'audio/PDF\n\n        // Contenu combiné (pour compatibilité avec workflows existants)\n        chatInput: combinedQuery,\n\n        // Métadonnées\n        processedAt: new Date().toISOString(),\n\n        // ❌ sessionId SUPPRIMÉ car :\n        // - Le frontend ne l'envoie pas\n        // - Le Memory node du Super Agent utilise l'email comme session ID\n        // - Simplicité > Complexité inutile\n    }\n}];\n"
      },
      "id": "e4c638f1-4f91-40fa-bace-62d97a7728d4",
      "name": "Context Merger",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        448,
        2864
      ]
    },
    {
      "parameters": {
        "content": "# Entrée et Audit",
        "height": 272,
        "width": 448
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -976,
        2832
      ],
      "typeVersion": 1,
      "id": "0f27c255-ba46-49bf-b080-c15c65cc553c",
      "name": "Sticky Note1"
    },
    {
      "parameters": {
        "content": "# Traitement selon type de contenant\n## Accepte inline, audio & pdf",
        "height": 720,
        "width": 1120,
        "color": 3
      },
      "type": "n8n-nodes-base.stickyNote",
      "position": [
        -496,
        2592
      ],
      "typeVersion": 1,
      "id": "e4d1f6e0-057e-457f-bcf7-32d3ef3443dc",
      "name": "Sticky Note2"
    },
    {
      "parameters": {
        "jsCode": "/**\n * PROMPT FACTORY - Nœud n8n (VERSION COMPLÈTE MULTILINGUE)\n * Centralise tous les prompts et messages bilingues (FR/EN)\n * \n * USAGE : Copiez ce code dans le nœud \"Prompt Factory\" de Backend Chat API\n * INPUT : Attend $json.lang ('fr' ou 'en') ou détecte depuis le texte\n * OUTPUT : Ajoute $json.prompts avec tous les textes traduits\n */\n\n// 1. Détection automatique de la langue\nconst inputJson = $json;\nlet detectedLang = inputJson.lang || 'fr'; // Défaut\n\n// Si aucune langue explicite, essayer de détecter depuis le texte utilisateur\nif (!inputJson.lang && inputJson.chatInput) {\n    const text = inputJson.chatInput.toLowerCase();\n    // Patterns simples pour détection rapide\n    if (/\\b(hello|hi|please|thank|there|what|how|why|when)\\b/.test(text)) {\n        detectedLang = 'en';\n    } else if (/\\b(bonjour|salut|svp|merci|comment|pourquoi|quand)\\b/.test(text)) {\n        detectedLang = 'fr';\n    } else if (/\\b(hola|gracias|que|como)\\b/.test(text)) {\n        detectedLang = 'es'; // espagnol -> sera traité en EN\n    } else if (/\\b(ciao|grazie|che|come)\\b/.test(text)) {\n        detectedLang = 'it'; // italien -> sera traité en EN\n    }\n}\n\n// Normalisation : Seuls 'fr' et 'en' sont officiellement supportés pour les prompts\n// Toutes les autres langues (es, it, de...) basculent sur 'en' (anglais international)\nconst supportedLangs = ['fr', 'en'];\nconst promptLang = supportedLangs.includes(detectedLang) ? detectedLang : 'en';\n\n// Langue pour les documents (CV/Lettre) : FR ou EN uniquement\nconst docLang = promptLang;\n\n// 2. Définition de TOUS les textes bilingues\nconst TRANSLATIONS = {\n    fr: {\n        errors: {\n            jwt_expired: \"🔒 Votre session a expiré. Veuillez vous reconnecter.\",\n            jwt_invalid: \"🔒 Token invalide. Veuillez vous authentifier à nouveau.\",\n            rate_limit: \"⏱️ Trop de tentatives. Réessayez dans quelques minutes.\",\n            invalid_file: \"❌ Type de fichier non supporté. Formats acceptés : PDF, TXT.\",\n            server_error: \"⚠️ Erreur serveur. Veuillez réessayer dans quelques instants.\",\n            auth_failed: \"❌ Code incorrect. Vérifiez votre saisie.\",\n            otp_expired: \"⏱️ Code expiré. Demandez-en un nouveau.\",\n            file_too_large: \"📦 Fichier trop volumineux. Maximum : 10 MB.\",\n            no_audio: \"🎤 Aucun audio détecté. Réessayez votre enregistrement.\",\n            access_denied: \"🚫 Accès refusé. Cette ressource nécessite des permissions spécifiques.\",\n        },\n        success: {\n            otp_sent: \"✅ Code envoyé par email. Vérifiez votre boîte de réception.\",\n            auth_success: \"🎉 Authentification réussie ! Bienvenue.\",\n            file_processed: \"✅ Fichier traité avec succès.\",\n        },\n        system_prompts: {\n            super_agent: `Tu es l'assistant IA de Philippe Gehringer, expert en management de transition et coaching professionnel.\n\nCONTEXTE UTILISATEUR :\n- Email authentifié : {{ $json.email }}\n- Permissions : {{ $json.user_labels }}\n- Langue détectée : ${detectedLang} (Mode réponse : ${promptLang.toUpperCase()})\n\nOUTILS DISPONIBLES :\n1. **load_profile_data** : Charge les données complètes de Philippe (persona + CV structuré)\n2. **check_user_rights** : Vérifie les droits d'accès\n3. **analyze_job_match** : Analyse une offre et calcule l'adéquation (0-100)\n4. **generate_cv_pdf** : Génère un CV PDF personnalisé\n5. **generate_cover_letter_pdf** : Génère une lettre de motivation PDF\n6. **send_email_with_attachments** : Envoie un email avec pièces jointes\n\nSTRATÉGIE D'UTILISATION :\n\n🔍 **Scénario 1 : Question sur le parcours de Philippe**\n→ Utilise 'load_profile_data' pour accéder aux informations\n→ Réponds directement en exploitant les données structurées\n\n🎯 **Scénario 2 : Analyse d'une offre d'emploi**\n→ 1) Utilise 'analyze_job_match' avec l'offre\n→ 2) Si score > 70% : Propose de générer CV + Cover Letter\n→ 3) Demande confirmation avant génération PDF\n\n📄 **Scénario 3 : Demande explicite de CV**\n→ Demande si c'est pour une offre spécifique (personnalisation)\n→ Utilise 'generate_cv_pdf'\n→ Propose l'envoi par email à {{ $json.email }}\n\n✉️ **Scénario 4 : Candidature complète**\n→ 1) 'analyze_job_match'\n→ 2) 'generate_cv_pdf' (personnalisé)\n→ 3) 'generate_cover_letter_pdf'\n→ 4) Demande confirmation pour 'send_email_with_attachments'\n\n📧 **Scénario 5 : Envoi par email**\n→ NE PAS envoyer automatiquement !\n→ NE JAMAIS demander l'adresse email (elle est déjà connue : {{ $json.email }})\n→ TOUJOURS demander confirmation d'abord :\n   \"Je vais t'envoyer ce document à {{ $json.email }}. Confirmes-tu ?\"\n→ Si OUI : utilise 'send_email_with_attachments' avec to_email = \"{{ $json.email }}\"\n→ Si NON : \"Pas de problème, je garde les documents disponibles.\"\n→ Après envoi : \"✅ Email envoyé avec succès à {{ $json.email }} !\"\n\n🔒 **RÈGLES DE SÉCURITÉ EMAIL (IMPÉRATIF) :**\n- L'email destinataire est TOUJOURS {{ $json.email }} (l'email authentifié du visiteur)\n- JAMAIS permettre à l'utilisateur de spécifier une autre adresse\n- Si l'utilisateur demande d'envoyer à une autre adresse, réponds :\n  \"Par mesure de sécurité, je peux uniquement envoyer à ton adresse enregistrée ({{ $json.email }}). C'est pour éviter tout usage abusif du système.\"\n\nRÈGLES IMPORTANTES :\n- TOUJOURS utiliser 'load_profile_data' avant de parler du parcours de Philippe\n- NE JAMAIS inventer des informations non présentes dans les données\n- Si génération PDF : Toujours proposer l'envoi par email à {{ $json.email }}\n- Être direct et professionnel (style Manager de Transition)\n- Utiliser du Markdown pour la mise en forme\n\nLANGUE DE RÉPONSE :\n→ L'utilisateur semble parler : ${detectedLang}\n→ TU DOIS RÉPONDRE EN : ${promptLang === 'fr' ? 'FRANÇAIS' : 'ANGLAIS'}\n→ Si la langue détectée n'est pas le français, utilise l'anglais par défaut.\n→ Documents générés : TOUJOURS en ${docLang.toUpperCase()}\n\nFORMAT DES RÉPONSES :\n- Utilise des **titres en gras**\n- Listes à puces pour clarté\n- Citations pour mettre en avant les points clés`,\n\n            tool_load_profile: \"Charge les données complètes du profil de Philippe (persona.yml + CV structuré). Utilise cet outil pour accéder aux informations sur le parcours, compétences, expertises, style de travail, etc.\",\n            \n            tool_check_rights: \"Vérifie si l'utilisateur a accès à une ressource selon ses labels. Paramètre : required_access ('brain_pro' | 'brain_shadow')\",\n            \n            tool_send_email: \"Envoie un email avec pièces jointes. IMPORTANT : 1) Toujours demander confirmation à l'utilisateur AVANT d'envoyer. 2) Le paramètre to_email doit TOUJOURS être l'email du contexte utilisateur ({{ $json.email }}), JAMAIS une adresse fournie par l'utilisateur. Paramètres : to_email (automatique depuis contexte), subject, body, attachments[]\",\n\n            job_analyzer: `Tu es un expert en analyse de recrutement.\n\nTA MISSION :\nAnalyse l'offre d'emploi fournie et extrait les informations clés.\n\nOFFRE D'EMPLOI :\n{{ job_description }}\n\nFORMAT DE SORTIE (JSON uniquement) :\n{\n  \"type\": \"offer\",\n  \"job_title\": \"Intitulé exact du poste\",\n  \"company_name\": \"Nom de l'entreprise (ou 'Non spécifié')\",\n  \"location\": \"Lieu (ou 'Non spécifié')\",\n  \"key_requirements\": [\n    \"Compétence technique 1\",\n    \"Compétence technique 2\",\n    \"Expérience requise\"\n  ],\n  \"mission_summary\": \"Résumé concis de la mission en 2-3 phrases\",\n  \"contract_type\": \"CDI/CDD/Mission/Freelance (ou 'Non spécifié')\",\n  \"context\": \"Secteur d'activité et contexte de l'entreprise\"\n}\n\nRÈGLES :\n- Extrait UNIQUEMENT les informations présentes dans l'offre\n- Si une info est absente, mets \"Non spécifié\"\n- Sois factuel, pas d'interprétation\n- Retourne du JSON valide uniquement`,\n\n            job_matcher: `Tu es Philippe Gehringer, manager de transition.\n\nCONTEXTE :\nVoici mes données professionnelles complètes :\n{{ profile_data }}\n\nOFFRE ANALYSÉE :\n{{ job_analysis }}\n\nTA MISSION :\nCalcule un score d'adéquation (0-100) entre mon profil et cette offre.\nAnalyse CHAQUE expérience de mon CV par rapport aux exigences du poste.\n\nFORMAT DE SORTIE (JSON uniquement) :\n{\n  \"global_fit_score\": 85,\n  \"global_analysis\": \"Analyse globale de l'adéquation en 3-4 phrases. Mets en avant les atouts principaux et points de vigilance éventuels.\",\n  \"experiences_match\": [\n    {\n      \"experience_id\": \"Description ou ID de l'expérience\",\n      \"score\": 95,\n      \"relevance\": \"Très pertinent car mobilise les compétences X, Y, Z requises par le poste\",\n      \"strategy\": \"À mettre en avant\"\n    }\n  ],\n  \"key_strengths\": [\"Point fort 1\", \"Point fort 2\"],\n  \"potential_gaps\": [\"Point de vigilance 1 (si applicable)\"],\n  \"recommended_angle\": \"Angle stratégique pour la candidature\"\n}\n\nRÈGLES :\n- Sois honnête sur le scoring (ni pessimiste ni optimiste)\n- Score global = moyenne pondérée des expériences pertinentes\n- Identifie 2-3 expériences clés à mettre en avant\n- Retourne du JSON valide uniquement`,\n\n            job_formatter: `Tu es Philippe Gehringer.\n\nCONTEXTE :\nVoici le résultat de mon analyse de matching :\n{{ matching_result }}\n\nTA MISSION :\nRédige une réponse professionnelle et engageante pour présenter cette analyse.\n\nSTRUCTURE DE LA RÉPONSE (Markdown) :\n## 🎯 Synthèse\n- Score d'adéquation : **XX%**\n- Avis global en 2-3 phrases (direct, pragmatique)\n\n## ✅ Expériences Clés\n- Cite les 2-3 expériences les plus pertinentes\n- Pour chaque : titre + 1 phrase sur la pertinence\n\n## 💡 Angle Stratégique\n- Propose l'angle de candidature recommandé\n- 1-2 phrases maximum\n\nTON :\n- Professionnel, direct, pragmatique\n- Style Manager de Transition\n- Pas de langue de bois\n\nLANGUE :\n→ TOUJOURS en FRANÇAIS (sauf si {{ lang }} = 'en')`,\n\n            cv_generator: `Tu es un expert en rédaction de CV pour managers de transition.\n\nDONNÉES DISPONIBLES :\n{{ profile_data }}\n\nLANGUE DU CV : {{ lang === 'en' ? 'ANGLAIS' : 'FRANÇAIS' }}\n\n{{ job_description ? 'OFFRE CIBLÉE (adapte le CV à cette offre) :\\n' + job_description : 'CV GÉNÉRIQUE (toutes expériences)' }}\n\nTA MISSION :\nRédige un CV professionnel au format HTML avec TailwindCSS.\n\nCONSIGNES OBLIGATOIRES :\n- Format A4 (210mm x 297mm)\n- Typographie moderne (Inter ou Roboto via Google Fonts)\n- Sections : En-tête, Résumé, Expériences, Formation, Compétences, Langues\n- Si offre fournie : ADAPTER le CV en mettant en avant les expériences pertinentes\n- Style : Clean, professionnel, lisible\n- Couleurs : Palette sobre (bleu marine #1e3a8a, gris #374151)\n- Marges : 20mm de chaque côté\n\nSTRUCTURE HTML OBLIGATOIRE :\n1. Inclure TailwindCSS via CDN\n2. Style pour impression A4\n3. En-tête avec nom, titre, contact\n4. Résumé professionnel (4-5 lignes)\n5. Expériences en reverse chronologique\n6. Formation\n7. Compétences (colonnes)\n8. Langues\n\nIMPORTANT : Encadre ton HTML complet avec les balises <GENERATE_PDF> et </GENERATE_PDF>\n\nExemple de structure :\n<GENERATE_PDF>\n<!DOCTYPE html>\n<html lang=\"{{ lang }}\">\n<head>\n  <meta charset=\"UTF-8\">\n  <script src=\"https://cdn.tailwindcss.com\"></script>\n  <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap\" rel=\"stylesheet\">\n  <style>\n    @page { size: A4; margin: 0; }\n    body { font-family: 'Inter', sans-serif; }\n  </style>\n</head>\n<body class=\"bg-white\">\n  <!-- Ton contenu CV ici -->\n</body>\n</html>\n</GENERATE_PDF>`,\n\n            cover_letter_generator: `Tu es un expert en rédaction de lettres de motivation pour managers de transition.\n\nDONNÉES DISPONIBLES :\n{{ profile_data }}\n\nOFFRE D'EMPLOI :\n{{ job_description }}\n\nENTREPRISE : {{ company_name }}\n\nLANGUE DE LA LETTRE : {{ lang === 'en' ? 'ANGLAIS (Cover Letter)' : 'FRANÇAIS (Lettre de Motivation)' }}\n\nTA MISSION :\nRédige une lettre de motivation professionnelle au format HTML avec TailwindCSS.\n\nSTRUCTURE OBLIGATOIRE :\n1. **En-tête** (Nom, Contact, Date, Destinataire)\n2. **Objet** : Candidature au poste de [titre]\n3. **Corps (3 paragraphes)** :\n   - §1 : Motivation et contexte (pourquoi ce poste m'intéresse)\n   - §2 : Adéquation profil/poste (2-3 expériences clés avec résultats concrets)\n   - §3 : Valeur ajoutée et disponibilité\n4. **Formule de politesse**\n5. **Signature**\n\nSTYLE :\n- Format A4 (1 page maximum)\n- Typographie élégante (Crimson Text ou Georgia via Google Fonts)\n- Ton : Direct, professionnel, confiant (style Manager de Transition)\n- Mise en lumière des expériences à haut score de matching\n- Pas de langue de bois, concret et factuel\n\nIMPORTANT : Encadre ton HTML complet avec les balises <GENERATE_PDF> et </GENERATE_PDF>\n\nExemple de structure :\n<GENERATE_PDF>\n<!DOCTYPE html>\n<html lang=\"{{ lang }}\">\n<head>\n  <meta charset=\"UTF-8\">\n  <script src=\"https://cdn.tailwindcss.com\"></script>\n  <link href=\"https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;600&display=swap\" rel=\"stylesheet\">\n  <style>\n    @page { size: A4; margin: 0; }\n    body { font-family: 'Crimson Text', serif; }\n  </style>\n</head>\n<body class=\"bg-white p-12\">\n  <!-- Ton contenu lettre ici -->\n</body>\n</html>\n</GENERATE_PDF>`\n        }\n    },\n\n    en: {\n        errors: {\n            jwt_expired: \"🔒 Your session has expired. Please log in again.\",\n            jwt_invalid: \"🔒 Invalid token. Please authenticate again.\",\n            rate_limit: \"⏱️ Too many attempts. Try again in a few minutes.\",\n            invalid_file: \"❌ Unsupported file type. Accepted formats: PDF, TXT.\",\n            server_error: \"⚠️ Server error. Please try again shortly.\",\n            auth_failed: \"❌ Incorrect code. Please check your input.\",\n            otp_expired: \"⏱️ Code expired. Request a new one.\",\n            file_too_large: \"📦 File too large. Maximum: 10 MB.\",\n            no_audio: \"🎤 No audio detected. Try recording again.\",\n            access_denied: \"🚫 Access denied. This resource requires specific permissions.\",\n        },\n        success: {\n            otp_sent: \"✅ Code sent by email. Check your inbox.\",\n            auth_success: \"🎉 Authentication successful! Welcome.\",\n            file_processed: \"✅ File processed successfully.\",\n        },\n        system_prompts: {\n            super_agent: `You are Philippe Gehringer's AI assistant, expert in transition management and professional coaching.\n\nUSER CONTEXT:\n- Authenticated email: {{ $json.email }}\n- Permissions: {{ $json.user_labels }}\n- Detected Language: ${detectedLang} (Bot Mode: ${promptLang.toUpperCase()})\n\nAVAILABLE TOOLS:\n1. **load_profile_data**: Load Philippe's complete profile data (persona + structured CV)\n2. **check_user_rights**: Check access rights\n3. **analyze_job_match**: Analyze an offer and calculate fit (0-100)\n4. **generate_cv_pdf**: Generate a personalized PDF resume\n5. **generate_cover_letter_pdf**: Generate a PDF cover letter\n6. **send_email_with_attachments**: Send an email with attachments\n\nUSAGE STRATEGY:\n\n🔍 **Scenario 1: Question about Philippe's background**\n→ Use 'load_profile_data' to access information\n→ Answer directly using structured data\n\n🎯 **Scenario 2: Job offer analysis**\n→ 1) Use 'analyze_job_match' with the offer\n→ 2) If score > 70%: Propose generating CV + Cover Letter\n→ 3) Ask for confirmation before PDF generation\n\n📄 **Scenario 3: Explicit CV request**\n→ Ask if it's for a specific offer (customization)\n→ Use 'generate_cv_pdf'\n→ Propose sending by email to {{ $json.email }}\n\n✉️ **Scenario 4: Complete application**\n→ 1) 'analyze_job_match'\n→ 2) 'generate_cv_pdf' (personalized)\n→ 3) 'generate_cover_letter_pdf'\n→ 4) Ask for confirmation for 'send_email_with_attachments'\n\n📧 **Scenario 5: Email sending**\n→ DO NOT send automatically!\n→ NEVER ask for the email address (it's already known: {{ $json.email }})\n→ ALWAYS ask for confirmation first:\n   \"I'll send this document to {{ $json.email }}. Do you confirm?\"\n→ If YES: use 'send_email_with_attachments' with to_email = \"{{ $json.email }}\"\n→ If NO: \"No problem, I'll keep the documents available.\"\n→ After sending: \"✅ Email sent successfully to {{ $json.email }}!\"\n\n🔒 **EMAIL SECURITY RULES (MANDATORY):**\n- The recipient email is ALWAYS {{ $json.email }} (the user's authenticated email)\n- NEVER allow the user to specify another address\n- If the user asks to send to another address, respond:\n  \"For security reasons, I can only send to your registered address ({{ $json.email }}). This prevents any misuse of the system.\"\n\nIMPORTANT RULES:\n- ALWAYS use 'load_profile_data' before talking about Philippe's background\n- NEVER invent information not present in the data\n- If PDF generation: Always propose email sending to {{ $json.email }}\n- Be direct and professional (Transition Manager style)\n- Use Markdown for formatting\n\nRESPONSE LANGUAGE:\n→ User appears to speak: ${detectedLang}\n→ YOU MUST RESPOND IN: ${promptLang === 'fr' ? 'FRENCH' : 'ENGLISH'}\n→ Documents language: ALWAYS ${docLang.toUpperCase()}\n\nRESPONSE FORMAT:\n- Use **bold titles**\n- Bullet lists for clarity\n- Quotes to highlight key points`,\n\n            tool_load_profile: \"Load Philippe Gehringer's complete profile data (persona.yml + structured CV). Use this tool to access information about professional background, skills, expertise, work style, etc.\",\n            \n            tool_check_rights: \"Check if user has access to a resource based on labels. Parameter: required_access ('brain_pro' | 'brain_shadow')\",\n            \n            tool_send_email: \"Send an email with attachments. IMPORTANT: 1) Always ask user for confirmation BEFORE sending. 2) The to_email parameter must ALWAYS be the user's context email ({{ $json.email }}), NEVER an address provided by the user. Parameters: to_email (automatic from context), subject, body, attachments[]\",\n\n            job_analyzer: `You are a recruitment analysis expert.\n\nYOUR MISSION:\nAnalyze the provided job offer and extract key information.\n\nJOB OFFER:\n{{ job_description }}\n\nOUTPUT FORMAT (JSON only):\n{\n  \"type\": \"offer\",\n  \"job_title\": \"Exact job title\",\n  \"company_name\": \"Company name (or 'Not specified')\",\n  \"location\": \"Location (or 'Not specified')\",\n  \"key_requirements\": [\"Technical skill 1\", \"Technical skill 2\", \"Required experience\"],\n  \"mission_summary\": \"Concise mission summary in 2-3 sentences\",\n  \"contract_type\": \"Permanent/Fixed-term/Mission/Freelance (or 'Not specified')\",\n  \"context\": \"Industry sector and company context\"\n}\n\nRULES:\n- Extract ONLY information present in the offer\n- If info is missing, put \"Not specified\"\n- Be factual, no interpretation\n- Return valid JSON only`,\n\n            job_matcher: `You are Philippe Gehringer, transition manager.\n\nCONTEXT:\nHere is my complete professional data:\n{{ profile_data }}\n\nANALYZED OFFER:\n{{ job_analysis }}\n\nYOUR MISSION:\nCalculate a fit score (0-100) between my profile and this offer.\nAnalyze EACH experience from my CV against the job requirements.\n\nOUTPUT FORMAT (JSON only):\n{\n  \"global_fit_score\": 85,\n  \"global_analysis\": \"Overall fit analysis in 3-4 sentences. Highlight main strengths and potential concerns.\",\n  \"experiences_match\": [\n    {\n      \"experience_id\": \"Experience description or ID\",\n      \"score\": 95,\n      \"relevance\": \"Highly relevant as it mobilizes X, Y, Z skills required\",\n      \"strategy\": \"Highlight this\"\n    }\n  ],\n  \"key_strengths\": [\"Strength 1\", \"Strength 2\"],\n  \"potential_gaps\": [\"Concern 1 (if applicable)\"],\n  \"recommended_angle\": \"Strategic angle for application\"\n}\n\nRULES:\n- Be honest with scoring (neither pessimistic nor optimistic)\n- Global score = weighted average of relevant experiences\n- Identify 2-3 key experiences to highlight\n- Return valid JSON only`,\n\n            job_formatter: `You are Philippe Gehringer.\n\nCONTEXT:\nHere is my matching analysis result:\n{{ matching_result }}\n\nYOUR MISSION:\nWrite a professional and engaging response to present this analysis.\n\nRESPONSE STRUCTURE (Markdown):\n## 🎯 Summary\n- Fit score: **XX%**\n- Overall opinion in 2-3 sentences (direct, pragmatic)\n\n## ✅ Key Experiences\n- List the 2-3 most relevant experiences\n- For each: title + 1 sentence on relevance\n\n## 💡 Strategic Angle\n- Propose the recommended application angle\n- 1-2 sentences maximum\n\nTONE:\n- Professional, direct, pragmatic\n- Transition Manager style\n- No corporate jargon\n\nLANGUAGE:\n→ ALWAYS in ENGLISH (unless {{ lang }} = 'fr')`,\n\n            cv_generator: `You are an expert in resume writing for transition managers.\n\nAVAILABLE DATA:\n{{ profile_data }}\n\nRESUME LANGUAGE: {{ lang === 'en' ? 'ENGLISH' : 'FRENCH' }}\n\n{{ job_description ? 'TARGETED OFFER (adapt resume to this offer):\\n' + job_description : 'GENERIC RESUME (all experiences)' }}\n\nYOUR MISSION:\nWrite a professional resume in HTML format with TailwindCSS.\n\nMANDATORY REQUIREMENTS:\n- A4 format (210mm x 297mm)\n- Modern typography (Inter or Roboto via Google Fonts)\n- Sections: Header, Summary, Experience, Education, Skills, Languages\n- If offer provided: ADAPT the resume by highlighting relevant experiences\n- Style: Clean, professional, readable\n- Colors: Sober palette (navy blue #1e3a8a, gray #374151)\n- Margins: 20mm on each side\n\nMANDATORY HTML STRUCTURE:\n1. Include TailwindCSS via CDN\n2. Style for A4 printing\n3. Header with name, title, contact\n4. Professional summary (4-5 lines)\n5. Experiences in reverse chronological order\n6. Education\n7. Skills (columns)\n8. Languages\n\nIMPORTANT: Wrap your complete HTML with <GENERATE_PDF> and </GENERATE_PDF> tags\n\nExample structure:\n<GENERATE_PDF>\n<!DOCTYPE html>\n<html lang=\"{{ lang }}\">\n<head>\n  <meta charset=\"UTF-8\">\n  <script src=\"https://cdn.tailwindcss.com\"></script>\n  <link href=\"https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap\" rel=\"stylesheet\">\n  <style>\n    @page { size: A4; margin: 0; }\n    body { font-family: 'Inter', sans-serif; }\n  </style>\n</head>\n<body class=\"bg-white\">\n  <!-- Your CV content here -->\n</body>\n</html>\n</GENERATE_PDF>`,\n\n            cover_letter_generator: `You are an expert in cover letter writing for transition managers.\n\nAVAILABLE DATA:\n{{ profile_data }}\n\nJOB OFFER:\n{{ job_description }}\n\nCOMPANY: {{ company_name }}\n\nLETTER LANGUAGE: {{ lang === 'en' ? 'ENGLISH (Cover Letter)' : 'FRENCH (Lettre de Motivation)' }}\n\nYOUR MISSION:\nWrite a professional cover letter in HTML format with TailwindCSS.\n\nMANDATORY STRUCTURE:\n1. **Header** (Name, Contact, Date, Recipient)\n2. **Subject**: Application for [job title]\n3. **Body (3 paragraphs)**:\n   - §1: Motivation and context (why this position interests me)\n   - §2: Profile/position fit (2-3 key experiences with concrete results)\n   - §3: Added value and availability\n4. **Closing formula**\n5. **Signature**\n\nSTYLE:\n- A4 format (1 page maximum)\n- Elegant typography (Crimson Text or Georgia via Google Fonts)\n- Tone: Direct, professional, confident (Transition Manager style)\n- Highlight high-scoring matching experiences\n- No corporate jargon, concrete and factual\n\nIMPORTANT: Wrap your complete HTML with <GENERATE_PDF> and </GENERATE_PDF> tags\n\nExample structure:\n<GENERATE_PDF>\n<!DOCTYPE html>\n<html lang=\"{{ lang }}\">\n<head>\n  <meta charset=\"UTF-8\">\n  <script src=\"https://cdn.tailwindcss.com\"></script>\n  <link href=\"https://fonts.googleapis.com/css2?family=Crimson+Text:wght@400;600&display=swap\" rel=\"stylesheet\">\n  <style>\n    @page { size: A4; margin: 0; }\n    body { font-family: 'Crimson Text', serif; }\n  </style>\n</head>\n<body class=\"bg-white p-12\">\n  <!-- Your letter content here -->\n</body>\n</html>\n</GENERATE_PDF>`\n        },\n        responses: {\n            shadow_brain_welcome: `[🗝️ PRIVATE MODE ACTIVATED]\n\nHello! I see you're one of our privileged guests.\n\nHere's what I can help you with:\n- Give you the Wifi code\n- Explain how to get the keys\n- Show you where the trash bins are\n- Answer practical questions about the accommodation\n\nWhat would you like to know?`,\n            access_denied_shadow: `🔒 This information requires guest access. To get the Wifi code and instructions, you must be registered as an Airbnb guest or Friend.`,\n        },\n        email_templates: {\n            otp_subject: \"Your Gehringer Conseil login code\",\n            otp_body: `Hello,\n\nHere is your login code: **{{ code }}**\n\nThis code is valid for 5 minutes.\n\nBy continuing, you accept that your email will be used to process your request.\n\nBest regards,\nGehringer Conseil Team`,\n            contact_subject: \"New contact request from chatbot\",\n            contact_body: `New contact request:\n\nEmail: {{ email }}\nMessage: {{ message }}\n\nSent from chatbot on {{ date }}.`,\n            cv_subject: \"Philippe Gehringer Resume{{ job_title ? ' - ' + job_title : '' }}\",\n            cv_body: `<html>\n<body style=\"font-family: Arial, sans-serif; line-height: 1.6; color: #333;\">\n  <p>Hello,</p>\n  \n  <p>Following your request, please find attached my resume{{ job_title ? ' customized for the <strong>' + job_title + '</strong> position' : '' }}.</p>\n  \n  {{ cover_letter_attached ? '<p>A personalized cover letter is also attached.</p>' : '' }}\n  \n  <p>I remain at your disposal for any additional information,</p>\n  \n  <p>Best regards,<br>\n  <strong>Philippe Gehringer</strong><br>\n  <em>Interim Manager</em></p>\n  \n  <hr style=\"border: none; border-top: 1px solid #ddd; margin: 20px 0;\">\n  <p style=\"font-size: 12px; color: #888;\">\n    This message was generated by Philippe Gehringer's AI assistant.<br>\n    For any question: <a href=\"mailto:contact@gehringer.fr\">contact@gehringer.fr</a>\n  </p>\n</body>\n</html>`,\n            application_subject: \"Application Philippe Gehringer - {{ job_title }}{{ company_name ? ' - ' + company_name : '' }}\",\n            application_body: `<html>\n<body style=\"font-family: Arial, sans-serif; line-height: 1.6; color: #333;\">\n  <p>Hello,</p>\n  \n  <p>I am writing to apply for the <strong>{{ job_title }}</strong> position{{ company_name ? ' at <strong>' + company_name + '</strong>' : '' }}.</p>\n  \n  <p>Please find attached:</p>\n  <ul>\n    <li>My resume customized for this opportunity</li>\n    <li>A cover letter detailing my fit for the position</li>\n  </ul>\n  \n  {{ matching_score ? '<p>My detailed analysis indicates a <strong>' + matching_score + '%</strong> fit with your needs.</p>' : '' }}\n  \n  <p>I remain at your entire disposal to discuss this opportunity.</p>\n  \n  <p>Best regards,<br>\n  <strong>Philippe Gehringer</strong><br>\n  <em>Interim Manager</em><br>\n  <a href=\"mailto:contact@gehringer.fr\">contact@gehringer.fr</a></p>\n  \n  <hr style=\"border: none; border-top: 1px solid #ddd; margin: 20px 0;\">\n  <p style=\"font-size: 12px; color: #888;\">\n    Documents generated by Philippe Gehringer's AI assistant.\n  </p>\n</body>\n</html>`\n        }\n    }\n};\n\n// 3. Sélection de la langue appropriée\nconst selectedTranslations = TRANSLATIONS[promptLang] || TRANSLATIONS['en'];\n\n// 4. Helper pour remplacer les variables\nfunction interpolate(template, vars) {\n    if (!template) return '';\n    return template.replace(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (match, key) => {\n        return vars[key] || match;\n    });\n}\n\n// 5. Retour avec toutes les traductions + données originales\nreturn [{\n    json: {\n        ...items[0].json,           // Données originales (email, user_labels...)\n        lang: promptLang,           // Langue utilisée (fr/en)\n        detected_lang: detectedLang, // Langue détectée brute\n        prompts: selectedTranslations, // Textes traduits\n        _interpolate: interpolate   // Helper\n    }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        720,
        2864
      ],
      "id": "0b1fe786-8579-4da4-9b1c-f1f0ca1dd165",
      "name": "Prompt Factory"
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "=={{ $json.chatInput }}",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 3.1,
      "position": [
        1248,
        2864
      ],
      "id": "d69811a1-7014-47be-b940-3f9153aa879c",
      "name": "AI Agent1"
    },
    {
      "parameters": {
        "sessionIdType": "customKey",
        "sessionKey": "=={{ $json.email }}",
        "contextWindowLength": 10
      },
      "type": "@n8n/n8n-nodes-langchain.memoryBufferWindow",
      "typeVersion": 1.3,
      "position": [
        912,
        3088
      ],
      "id": "408b273c-a2b5-46dc-bdf1-0d550be27fd4",
      "name": "Simple Memory"
    },
    {
      "parameters": {
        "description": "Vérifie si l'utilisateur a le droit d'accéder à une ressource spécifique. Paramètre OBLIGATOIRE : required_access ('brain_pro' pour accès professionnel, 'brain_shadow' pour mode invité). Retourne has_access (boolean) et un message.",
        "jsCode": "// ============================================\n// TOOL : CHECK USER RIGHTS (Version Sans Schéma)\n// ============================================\n\n// Récupération des labels utilisateur depuis le contexte\nconst contextNode = $('Super Agent (CAG Pro)').first();\nconst userLabels = contextNode?.json?.user_labels || [];\nconst lang = contextNode?.json?.lang || 'fr';\n\n// Récupération du paramètre du tool\n// Le LLM peut passer soit un objet, soit directement la string\nconst toolInput = $input.first().json;\nlet requestedAccess = 'brain_pro';\n\nif (typeof toolInput === 'string') {\n    // Si c'est une string directe\n    requestedAccess = toolInput;\n} else if (toolInput.required_access) {\n    // Si c'est un objet avec le paramètre\n    requestedAccess = toolInput.required_access;\n} else if (toolInput.query) {\n    // Fallback si le LLM utilise \"query\"\n    requestedAccess = toolInput.query;\n}\n\n// Normaliser la valeur\nif (requestedAccess.includes('shadow')) {\n    requestedAccess = 'brain_shadow';\n} else {\n    requestedAccess = 'brain_pro';\n}\n\n// ============================================\n// RÈGLES D'ACCÈS\n// ============================================\n\nconst accessRules = {\n    brain_pro: {\n        allowed: true,\n        reason: {\n            fr: \"Accès Brain Pro autorisé pour tous les utilisateurs\",\n            en: \"Brain Pro access granted for all users\"\n        }\n    },\n    \n    brain_shadow: {\n        allowed: userLabels.length > 0 && userLabels.some(label => \n            ['Airbnb', 'Ami', 'Famille'].includes(label)\n        ),\n        reason: {\n            fr: userLabels.length > 0 && userLabels.some(label => ['Airbnb', 'Ami', 'Famille'].includes(label))\n                ? \"Accès Brain Shadow autorisé (invité privilégié)\"\n                : \"Accès Brain Shadow refusé (réservé aux invités Airbnb, Ami, Famille)\",\n            en: userLabels.length > 0 && userLabels.some(label => ['Airbnb', 'Ami', 'Famille'].includes(label))\n                ? \"Brain Shadow access granted (privileged guest)\"\n                : \"Brain Shadow access denied (reserved for Airbnb, Friend, Family guests)\"\n        }\n    }\n};\n\nconst rule = accessRules[requestedAccess] || accessRules.brain_pro;\n\n// ============================================\n// MESSAGES DE RÉPONSE\n// ============================================\n\nconst messages = {\n    fr: {\n        granted: `✅ Accès autorisé à ${requestedAccess}`,\n        denied: `🚫 Accès refusé à ${requestedAccess}`\n    },\n    en: {\n        granted: `✅ Access granted to ${requestedAccess}`,\n        denied: `🚫 Access denied to ${requestedAccess}`\n    }\n};\n\nconst currentLang = messages[lang] || messages.fr;\n\n// ============================================\n// OUTPUT\n// ============================================\n\nreturn [{\n    json: {\n        has_access: rule.allowed,\n        requested_access: requestedAccess,\n        user_labels: userLabels,\n        user_labels_count: userLabels.length,\n        message: rule.allowed ? currentLang.granted : currentLang.denied,\n        reason: rule.reason[lang] || rule.reason.fr,\n        timestamp: new Date().toISOString()\n    }\n}];"
      },
      "type": "@n8n/n8n-nodes-langchain.toolCode",
      "typeVersion": 1.3,
      "position": [
        1264,
        3088
      ],
      "id": "2de9c687-04b9-4bb4-8710-076668813e64",
      "name": "check_user_rights"
    },
    {
      "parameters": {
        "description": "Charge les données complètes du profil de Philippe Gehringer (persona.yml + CV structuré). Utilise cet outil pour accéder aux informations sur le parcours professionnel, les compétences, les expertises, le style de travail. Retourne un JSON avec persona et cv (experiences, education, skills, languages).",
        "workflowId": {
          "__rl": true,
          "value": "ZAqbZfzpGbCZE0dtzEYvw",
          "mode": "list",
          "cachedResultUrl": "/workflow/ZAqbZfzpGbCZE0dtzEYvw",
          "cachedResultName": "Load Profile Data"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        1088,
        3088
      ],
      "id": "6c55afdd-d056-4175-aaa7-bb6f05917c2c",
      "name": "load_profile_data"
    },
    {
      "parameters": {
        "description": "Envoie un email avec pièces jointes. IMPORTANT : 1) Toujours demander confirmation à l'utilisateur AVANT d'envoyer. 2) Le paramètre to_email doit TOUJOURS être l'email du contexte utilisateur ({{ $json.email }}), JAMAIS une adresse fournie par l'utilisateur. Paramètres : to_email (automatique), subject, body, attachments[]",
        "workflowId": {
          "__rl": true,
          "value": "zCfKQUDrjiyayKQ-lkPdA",
          "mode": "list",
          "cachedResultUrl": "/workflow/zCfKQUDrjiyayKQ-lkPdA",
          "cachedResultName": "Send Email with Attachments"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "to_email": "={{ $json.email }}",
            "lang": "={{ $json.lang }}",
            "subject": "={{ $fromAI('subject') }}",
            "body": "={{ $fromAI('body') }}",
            "attachments": "={{ $fromAI('attachments', []) }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "to_email",
              "displayName": "to_email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "subject",
              "displayName": "subject",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "body",
              "displayName": "body",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "attachments",
              "displayName": "attachments",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "lang",
              "displayName": "lang",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        1888,
        3088
      ],
      "id": "c7234276-cdc9-41b0-8534-9fe54dfaa36b",
      "name": "send_email_with_attachments"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{ { \"output\": $json.output } }}",
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.5,
      "position": [
        1872,
        2864
      ],
      "id": "32ef8392-ceb3-4862-8fb0-7d01a5656b81",
      "name": "Response Chat"
    },
    {
      "parameters": {
        "description": "Analyse une offre d'emploi (texte ou description) et calcule l'adéquation (score 0-100) avec le profil de Philippe. Retourne une analyse détaillée des points forts, des manques éventuels et une stratégie de candidature. Paramètre obligatoire : job_description (le texte complet de l'offre). Utilise cet outil dès que l'utilisateur partage une offre d'emploi ou demande si Philippe correspond à un poste.",
        "workflowId": {
          "__rl": true,
          "value": "dxmxz9mAllX0kv0_d2Qby",
          "mode": "list",
          "cachedResultUrl": "/workflow/dxmxz9mAllX0kv0_d2Qby",
          "cachedResultName": "Analyze Job Match"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {},
          "matchingColumns": [],
          "schema": [],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        1424,
        3088
      ],
      "id": "56dfd581-4c24-4ac2-abde-7f549aa2b862",
      "name": "analyze_job_match"
    },
    {
      "parameters": {
        "model": {
          "__rl": true,
          "value": "gpt-4o",
          "mode": "list",
          "cachedResultName": "gpt-4o"
        },
        "builtInTools": {},
        "options": {
          "maxTokens": 4000,
          "temperature": 0.4
        }
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatOpenAi",
      "typeVersion": 1.3,
      "position": [
        752,
        3088
      ],
      "id": "defb8e66-effc-4906-b76b-3f35a6225635",
      "name": "OpenAI Chat Model3",
      "credentials": {
        "openAiApi": {
          "id": "pe1RxUmCYaJzcwAP",
          "name": "OpenAi account"
        }
      }
    },
    {
      "parameters": {
        "description": "Génère un CV personnalisé au format PDF. Analyse l'offre d'emploi pour adapter les expériences et le résumé. Paramètres : job_description (optionnel), lang (fr/en). Retourne un fichier binaire PDF. Utilise cet outil quand l'utilisateur demande un CV ou après une analyse d'offre positive.",
        "workflowId": {
          "__rl": true,
          "value": "erM8v0UNuyhh9SdtV1Tf9",
          "mode": "list",
          "cachedResultUrl": "/workflow/erM8v0UNuyhh9SdtV1Tf9",
          "cachedResultName": "Generate CV PDF"
        },
        "workflowInputs": {
          "mappingMode": "defineBelow",
          "value": {
            "email": "={{ $json.email }}",
            "lang": "={{ $json.lang }}",
            "user_labels": "={{ $json.user_labels }}",
            "job_description": "={{ $fromAI('job_description') }}"
          },
          "matchingColumns": [],
          "schema": [
            {
              "id": "email",
              "displayName": "email",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "lang",
              "displayName": "lang",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "user_labels",
              "displayName": "user_labels",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            },
            {
              "id": "job_description",
              "displayName": "job_description",
              "required": false,
              "defaultMatch": false,
              "display": true,
              "canBeUsedToMatch": true,
              "type": "string",
              "removed": false
            }
          ],
          "attemptToConvertTypes": false,
          "convertFieldsToString": false
        }
      },
      "type": "@n8n/n8n-nodes-langchain.toolWorkflow",
      "typeVersion": 2.2,
      "position": [
        1584,
        3088
      ],
      "id": "5cee680b-fad8-4f33-8163-f01074f86582",
      "name": "generate_cv_pdf"
    }
  ],
  "pinData": {
    "Webhook (Entrée Unique)": [
      {
        "json": {
          "headers": {
            "host": "n8n.gehringer.fr",
            "user-agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/143.0.0.0 Safari/537.36",
            "content-length": "384647",
            "accept": "application/json, text/plain, */*",
            "accept-encoding": "gzip, br",
            "accept-language": "en-US,en;q=0.9,fr;q=0.8",
            "authorization": "Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJleHBpcmVzSW4iOjkwMCwiZW1haWwiOiJmaWZvdWRlQGhvdG1haWwuY29tIiwidXNlcl9sYWJlbHMiOiIiLCJpYXQiOjE3Njg0MjY3OTd9.wso_zS1ecZHkyTPTzZ4kLYh-qt8e8WEU3Md41d9ZPoI",
            "cdn-loop": "cloudflare; loops=1",
            "cf-connecting-ip": "2a01:e0a:183:7c60:7d4e:2fb1:d5bd:4a82",
            "cf-ipcountry": "FR",
            "cf-ray": "9bed040428c80279-CDG",
            "cf-visitor": "{\"scheme\":\"https\"}",
            "cf-warp-tag-id": "b58e200c-9718-4899-9cc5-972a6e49f296",
            "connection": "keep-alive",
            "content-type": "multipart/form-data; boundary=----WebKitFormBoundarynEBRBpWXWOeBWQH9",
            "origin": "http://localhost:4321",
            "priority": "u=1, i",
            "referer": "http://localhost:4321/",
            "sec-ch-ua": "\"Google Chrome\";v=\"143\", \"Chromium\";v=\"143\", \"Not A(Brand\";v=\"24\"",
            "sec-ch-ua-mobile": "?0",
            "sec-ch-ua-platform": "\"Windows\"",
            "sec-fetch-dest": "empty",
            "sec-fetch-mode": "cors",
            "sec-fetch-site": "cross-site",
            "x-forwarded-for": "2a01:e0a:183:7c60:7d4e:2fb1:d5bd:4a82",
            "x-forwarded-proto": "https"
          },
          "params": {},
          "query": {},
          "body": {
            "action": "chat-message",
            "history": "[]"
          },
          "webhookUrl": "https://n8n.gehringer.fr/webhook/chat-api",
          "executionMode": "production"
        },
        "binary": {
          "file": {
            "mimeType": "application/pdf",
            "fileType": "pdf",
            "fileExtension": "pdf",
            "data": "filesystem-v2",
            "fileName": "Offre Emploi CDI Directeur Régional Paris (75) - Recrutement par Murano _ Hellowork.pdf",
            "id": "filesystem-v2:workflows/eBBXkB0vqJOsW6g8/executions/temp/binary_data/9f083239-56a3-418c-be94-f35ba4c690a2",
            "fileSize": "384 kB"
          }
        },
        "pairedItem": {
          "item": 0
        }
      }
    ]
  },
  "connections": {
    "Webhook (Entrée Unique)": {
      "main": [
        [
          {
            "node": "Input Validation",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router (Switch Action)": {
      "main": [
        [
          {
            "node": "Get Rate Limit Init",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get Rate Limit Verify",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Hash Incoming Token",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Sécurité (Vérifier JWT)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Code OTP": {
      "main": [
        [
          {
            "node": "Sécu: Stocker Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Vérifier Code (Mock)": {
      "main": [
        [
          {
            "node": "Supprimé Code Utilisé",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sécurité (Vérifier JWT)": {
      "main": [
        [
          {
            "node": "Log: Chat Message",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Whisper (STT)": {
      "main": [
        [
          {
            "node": "Context Merger",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Réponse Init": {
      "main": [
        [
          {
            "node": "Send email",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sécu: Stocker Code": {
      "main": [
        [
          {
            "node": "Réponse Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get stored OTP code": {
      "main": [
        [
          {
            "node": "Vérifier Code (Mock)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get CRM Contact": {
      "main": [
        [
          {
            "node": "Update CRM",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update CRM": {
      "main": [
        [
          {
            "node": "Générer Code OTP",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code in JavaScript1": {
      "main": [
        [
          {
            "node": "Whisper (STT)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get All Groups": {
      "main": [
        [
          {
            "node": "Merge Groups Names",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Google Contacts": {
      "main": [
        [
          {
            "node": "Get All Groups",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Merge Groups Names": {
      "main": [
        [
          {
            "node": "Log: Auth Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Router (Content Type)": {
      "main": [
        [
          {
            "node": "Code in JavaScript1",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Restore Binary",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Context Merger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Restore Binary": {
      "main": [
        [
          {
            "node": "File Gatekeeper",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Supprimé Code Utilisé": {
      "main": [
        [
          {
            "node": "Check Google Contacts",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Access Token": {
      "main": [
        [
          {
            "node": "Générer Refresh Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Refresh Token": {
      "main": [
        [
          {
            "node": "Sauvegarder Refresh Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sauvegarder Refresh Token": {
      "main": [
        [
          {
            "node": "Réponse Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log: Auth Success": {
      "main": [
        [
          {
            "node": "Générer Access Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log: Auth Failed": {
      "main": [
        [
          {
            "node": "Erreur Auth",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Log: Chat Message": {
      "main": [
        [
          {
            "node": "Router (Content Type)",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Normaliseur d'Erreur": {
      "main": [
        [
          {
            "node": "Log: Auth Failed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Hash Incoming Token": {
      "main": [
        [
          {
            "node": "Get Refresh Token Info",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Refresh Token Info": {
      "main": [
        [
          {
            "node": "Validate & Rotate",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Validate & Rotate": {
      "main": [
        [
          {
            "node": "Delete Old Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Delete Old Token": {
      "main": [
        [
          {
            "node": "Générer Access Token 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Access Token 1": {
      "main": [
        [
          {
            "node": "Générer Refresh Token 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Générer Refresh Token 1": {
      "main": [
        [
          {
            "node": "Sauvegarder Refresh Token 1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Sauvegarder Refresh Token 1": {
      "main": [
        [
          {
            "node": "Réponse Token",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Rate Limit Init": {
      "main": [
        [
          {
            "node": "Check Limit Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Limit Init": {
      "main": [
        [
          {
            "node": "Update Rate Limit Init",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Rate Limit Init": {
      "main": [
        [
          {
            "node": "Block or Pass",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Get Rate Limit Verify": {
      "main": [
        [
          {
            "node": "Check Limit Verify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Check Limit Verify": {
      "main": [
        [
          {
            "node": "Update Rate Limit Verify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Rate Limit Verify": {
      "main": [
        [
          {
            "node": "Block or Pass Verify",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Block or Pass": {
      "main": [
        [
          {
            "node": "Throw Error",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get CRM Contact",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Block or Pass Verify": {
      "main": [
        [
          {
            "node": "Throw Error Verify",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Get stored OTP code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Send email": {
      "main": [
        [],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Throw Error": {
      "main": [
        [],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Throw Error Verify": {
      "main": [
        [],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Input Validation": {
      "main": [
        [
          {
            "node": "Router (Switch Action)",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Normaliseur d'Erreur",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "File Gatekeeper": {
      "main": [
        [
          {
            "node": "Context Merger",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Context Merger": {
      "main": [
        [
          {
            "node": "Prompt Factory",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Prompt Factory": {
      "main": [
        [
          {
            "node": "AI Agent1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Simple Memory": {
      "ai_memory": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_memory",
            "index": 0
          }
        ]
      ]
    },
    "check_user_rights": {
      "ai_tool": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "load_profile_data": {
      "ai_tool": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "send_email_with_attachments": {
      "ai_tool": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent1": {
      "main": [
        [
          {
            "node": "Response Chat",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "analyze_job_match": {
      "ai_tool": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    },
    "OpenAI Chat Model3": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    },
    "generate_cv_pdf": {
      "ai_tool": [
        [
          {
            "node": "AI Agent1",
            "type": "ai_tool",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": true,
  "settings": {
    "executionOrder": "v1",
    "availableInMCP": true,
    "callerPolicy": "workflowsFromSameOwner"
  },
  "versionId": "a8b7c35e-55cc-4af9-a9ea-dd5a4306a393",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "2194913e407b1e503ee1051e748fa0b50f28c847d89d91263b2430bdb12da207"
  },
  "id": "eBBXkB0vqJOsW6g8",
  "tags": [
    {
      "updatedAt": "2026-01-12T16:26:32.123Z",
      "createdAt": "2026-01-12T16:26:32.123Z",
      "id": "0xE9WHXJKvU4ffh4",
      "name": "Chatbot"
    }
  ]
}